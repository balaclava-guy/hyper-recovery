name: Visual Smoke Test

on:
  workflow_run:
    workflows: ["Fetch & Store Artifacts"]
    types: [completed]
    branches: [main]
  workflow_dispatch:
    inputs:
      fetch_run_id:
        description: "Run ID of the Fetch & Store Artifacts workflow"
        required: true

jobs:
  visual-smoke:
    if: |
      (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success') ||
      github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    timeout-minutes: 20
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.workflow_run.head_sha || github.sha }}

      - name: Select source workflow run
        id: source-run
        run: |
          if [ "${{ github.event_name }}" = "workflow_run" ]; then
            echo "run_id=${{ github.event.workflow_run.id }}" >> "$GITHUB_OUTPUT"
          else
            echo "run_id=${{ inputs.fetch_run_id }}" >> "$GITHUB_OUTPUT"
          fi

      - name: Download live ISO artifact
        uses: actions/download-artifact@v4
        with:
          name: live-iso
          path: dist/live
          run-id: ${{ steps.source-run.outputs.run_id }}
          github-token: ${{ secrets.GITHUB_TOKEN }}

      - name: Check if debug ISO artifact exists
        id: debug-artifact
        uses: actions/github-script@v7
        with:
          script: |
            const runId = Number('${{ steps.source-run.outputs.run_id }}');
            const { data } = await github.rest.actions.listWorkflowRunArtifacts({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: runId,
              per_page: 100,
            });
            const hasDebugIso = data.artifacts.some((artifact) =>
              artifact.name === "debug-iso" && !artifact.expired
            );
            core.info(`debug-iso present: ${hasDebugIso}`);
            core.setOutput("present", hasDebugIso ? "true" : "false");

      - name: Download debug ISO artifact (optional)
        if: steps.debug-artifact.outputs.present == 'true'
        uses: actions/download-artifact@v4
        with:
          name: debug-iso
          path: dist/debug
          run-id: ${{ steps.source-run.outputs.run_id }}
          github-token: ${{ secrets.GITHUB_TOKEN }}

      - name: Install QEMU + Tools
        run: |
          sudo apt-get update
          sudo apt-get install -y qemu-system-x86 qemu-utils socat imagemagick ovmf ffmpeg p7zip-full
          # Verify OVMF path
          ls -la /usr/share/OVMF/ || ls -la /usr/share/ovmf/ || ls -la /usr/share/edk2/
          echo "OVMF files found at:"
          find /usr/share -name "OVMF*.fd" 2>/dev/null | head -5

      - name: Extract ISO artifacts
        run: |
          set -euo pipefail

          LIVE_7Z=$(ls dist/live/*.7z | head -1)
          mkdir -p dist/live/extracted
          7z x "$LIVE_7Z" -odist/live/extracted >/dev/null
          ISO_PATH=$(ls dist/live/extracted/*.iso | head -1)
          echo "ISO_PATH=$ISO_PATH" >> $GITHUB_ENV

          ISO_DEBUG_PATH=""
          if ls dist/debug/*.7z >/dev/null 2>&1; then
            DEBUG_7Z=$(ls dist/debug/*.7z | head -1)
            mkdir -p dist/debug/extracted
            7z x "$DEBUG_7Z" -odist/debug/extracted >/dev/null
            ISO_DEBUG_PATH=$(ls dist/debug/extracted/*.iso | head -1)
          fi
          echo "ISO_DEBUG_PATH=$ISO_DEBUG_PATH" >> $GITHUB_ENV

      - name: Boot ISO and capture visuals
        shell: bash
        run: |
          set -euo pipefail

          mkdir -p artifacts

          # Find OVMF firmware files (prefer non-secureboot for compatibility)
          OVMF_CODE=$(find /usr/share -name "OVMF_CODE*.fd" 2>/dev/null | grep -v snakeoil | grep -v ms | grep -v secboot | head -1)
          if [ -z "$OVMF_CODE" ]; then
            # Fall back to secureboot version if needed
            OVMF_CODE=$(find /usr/share -name "OVMF_CODE*.fd" 2>/dev/null | grep -v snakeoil | grep -v ms | head -1)
          fi
          OVMF_VARS_TEMPLATE=$(find /usr/share -name "OVMF_VARS*.fd" 2>/dev/null | grep -v snakeoil | grep -v ms | head -1)
          echo "Using OVMF_CODE: $OVMF_CODE"
          echo "Using OVMF_VARS template: $OVMF_VARS_TEMPLATE"

          if [ -z "$OVMF_CODE" ] || [ -z "$OVMF_VARS_TEMPLATE" ]; then
            echo "ERROR: OVMF firmware files not found"
            echo "Available OVMF files:"
            find /usr/share -name "OVMF*.fd" 2>/dev/null || true
            exit 1
          fi

          VIDEO_SECONDS=120

          run_boot() {
            local mode=$1
            local vnc_port=$2
            local monitor_socket=$3
            local serial_log=$4
            local prefix=$5
            local iso_path=$6
            shift 6
            local firmware_args=("$@")

            # For EFI boot, use -drive instead of -cdrom for better compatibility
            if [ -n "${firmware_args[*]}" ]; then
              # EFI mode - use drive format for ISO
              qemu-system-x86_64 \
                -m 2048 -smp 2 \
                -device virtio-gpu-pci \
                -display none \
                -vnc :"$vnc_port" \
                -serial file:"$serial_log" \
                -monitor unix:"$monitor_socket",server,nowait \
                -drive file="$iso_path",format=raw,if=none,id=drive-cd,readonly=on \
                -device ahci,id=ahci \
                -device ide-cd,drive=drive-cd,bus=ahci.0 \
                -boot order=d \
                -no-reboot \
                "${firmware_args[@]}" &
            else
              # BIOS mode - use simple cdrom
              qemu-system-x86_64 \
                -m 2048 -smp 2 \
                -device virtio-gpu-pci \
                -display none \
                -vnc :"$vnc_port" \
                -serial file:"$serial_log" \
                -monitor unix:"$monitor_socket",server,nowait \
                -cdrom "$iso_path" \
                -boot d \
                -no-reboot \
                "${firmware_args[@]}" &
            fi

            QEMU_PID=$!

            # Wait for monitor socket
            for i in {1..30}; do
              if [ -S "$monitor_socket" ]; then
                break
              fi
              sleep 1
            done

            # Wait for VNC port
            for i in {1..30}; do
              if (echo > /dev/tcp/127.0.0.1/$((5900 + vnc_port))) >/dev/null 2>&1; then
                break
              fi
              sleep 1
            done

            # Start frame capture loop for video creation (runs in background)
            (
              mkdir -p "artifacts/${prefix}-frames"
              for i in {0..300}; do  # Capture ~60 seconds at 5 FPS
                printf "screendump artifacts/${prefix}-frames/frame%04d.ppm\n" "$i" | socat - UNIX-CONNECT:"$monitor_socket" 2>/dev/null || true
                sleep 0.2  # 5 FPS
              done
            ) &
            CAPTURE_PID=$!

            capture_shot() {
              local name=$1
              printf "screendump artifacts/%s.ppm\n" "$name" | socat - UNIX-CONNECT:"$monitor_socket"
              convert "artifacts/$name.ppm" "artifacts/$name.png"
            }

            # Extended screenshot timing to capture Plymouth boot animation
            # GRUB auto-boots after ~5s, then kernel loads, then Plymouth runs
            sleep 5
            capture_shot "${prefix}-shot1"  # GRUB menu
            sleep 10
            capture_shot "${prefix}-shot2"  # Kernel loading / early Plymouth
            sleep 10
            capture_shot "${prefix}-shot3"  # Plymouth animation
            sleep 10
            capture_shot "${prefix}-shot4"  # Plymouth animation continues
            sleep 10
            capture_shot "${prefix}-shot5"  # Late Plymouth / login screen
            sleep 15
            capture_shot "${prefix}-shot6"  # Post-boot / login screen

            # Brightness check across all screenshots
            mean1=$(convert "artifacts/${prefix}-shot1.png" -colorspace gray -format "%[mean]" info:)
            mean2=$(convert "artifacts/${prefix}-shot2.png" -colorspace gray -format "%[mean]" info:)
            mean3=$(convert "artifacts/${prefix}-shot3.png" -colorspace gray -format "%[mean]" info:)
            mean4=$(convert "artifacts/${prefix}-shot4.png" -colorspace gray -format "%[mean]" info:)
            mean5=$(convert "artifacts/${prefix}-shot5.png" -colorspace gray -format "%[mean]" info:)
            mean6=$(convert "artifacts/${prefix}-shot6.png" -colorspace gray -format "%[mean]" info:)

            echo "$mode shot means: $mean1 $mean2 $mean3 $mean4 $mean5 $mean6"

            is_bright=$(awk -v m1="$mean1" -v m2="$mean2" -v m3="$mean3" -v m4="$mean4" -v m5="$mean5" -v m6="$mean6" 'BEGIN {print ((m1>0.02)||(m2>0.02)||(m3>0.02)||(m4>0.02)||(m5>0.02)||(m6>0.02)) ? 1 : 0}')
            if [ "$is_bright" -ne 1 ]; then
              echo "WARNING: $mode screenshots are too dark. Plymouth may be missing."
            else
              echo "$mode brightness check: PASS"
            fi

            # Shutdown QEMU
            printf "system_powerdown\n" | socat - UNIX-CONNECT:"$monitor_socket" || true
            sleep 3
            kill "$QEMU_PID" || true
            kill "$CAPTURE_PID" 2>/dev/null || true
            
            # Convert captured frames to video
            if [ -d "artifacts/${prefix}-frames" ] && [ "$(ls -A artifacts/${prefix}-frames/*.ppm 2>/dev/null | wc -l)" -gt 0 ]; then
              ffmpeg -y -framerate 5 -pattern_type glob -i "artifacts/${prefix}-frames/*.ppm" \
                -vcodec libx264 -preset fast -crf 23 -pix_fmt yuv420p \
                "artifacts/${prefix}-boot.mp4" 2>/dev/null || echo "Video creation failed for $mode"
              rm -rf "artifacts/${prefix}-frames"  # Clean up frames
            fi
          }

          # BIOS boot test (main ISO)
          run_boot "bios" 1 /tmp/qemu-monitor-bios artifacts/serial-bios.log bios "$ISO_PATH"

          # EFI boot test (main ISO)
          EFI_VARS="/tmp/OVMF_VARS.fd"
          cp "$OVMF_VARS_TEMPLATE" "$EFI_VARS"
          run_boot "efi" 2 /tmp/qemu-monitor-efi artifacts/serial-efi.log efi "$ISO_PATH" \
            -drive if=pflash,format=raw,readonly=on,file="$OVMF_CODE" \
            -drive if=pflash,format=raw,file="$EFI_VARS"

          # EFI boot test (debug ISO with hyper.debug=1) when available
          if [ -n "${ISO_DEBUG_PATH:-}" ] && [ -f "$ISO_DEBUG_PATH" ]; then
            EFI_VARS_DEBUG="/tmp/OVMF_VARS_DEBUG.fd"
            cp "$OVMF_VARS_TEMPLATE" "$EFI_VARS_DEBUG"
            run_boot "debug-efi" 3 /tmp/qemu-monitor-debug artifacts/serial-debug-efi.log debug-efi "$ISO_DEBUG_PATH" \
              -drive if=pflash,format=raw,readonly=on,file="$OVMF_CODE" \
              -drive if=pflash,format=raw,file="$EFI_VARS_DEBUG"
          else
            echo "No debug ISO artifact found; skipping debug EFI boot test."
          fi

      - name: Upload visual artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: visual-smoke
          path: |
            artifacts/bios-shot*.png
            artifacts/efi-shot*.png
            artifacts/debug-efi-shot*.png
            artifacts/*-boot.mp4
            artifacts/serial-*.log
          if-no-files-found: warn
