name: Visual Smoke Test

on:
  workflow_dispatch:
    inputs:
      preview:
        description: "Start a browser-accessible VM preview (exposes a temporary tunnel)"
        required: false
        default: "false"
  push:
    branches: [main]

jobs:
  visual-smoke:
    runs-on: ubuntu-latest
    timeout-minutes: 20
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Install Nix
        uses: cachix/install-nix-action@v27
        with:
          extra_nix_config: |
            substituters = https://cache.nixos.org https://cache.garnix.io
            trusted-public-keys = cache.nixos.org-1:6NCHdD59X431o0gWypbMrAURkbJ16ZPMQFGspcDShjY= cache.garnix.io:CTFPyKSLcx5RMJKfLo5EEPUObbA78b0YQ2DTCJXqr9g=

      - name: Install QEMU + Tools
        run: |
          sudo apt-get update
          sudo apt-get install -y qemu-system-x86 qemu-utils socat imagemagick ovmf ffmpeg
          # Verify OVMF path
          ls -la /usr/share/OVMF/ || ls -la /usr/share/ovmf/ || ls -la /usr/share/edk2/
          echo "OVMF files found at:"
          find /usr/share -name "OVMF*.fd" 2>/dev/null | head -5

      - name: Build ISO
        run: |
          nix build .#packages.x86_64-linux.usb --out-link result-iso --print-build-logs --refresh
          nix build .#packages.x86_64-linux.usb-debug --out-link result-iso-debug --print-build-logs --refresh
          ISO_PATH=$(ls result-iso/iso/*.iso | head -1)
          ISO_DEBUG_PATH=$(ls result-iso-debug/iso/*.iso | head -1)
          echo "ISO_PATH=$ISO_PATH" >> $GITHUB_ENV
          echo "ISO_DEBUG_PATH=$ISO_DEBUG_PATH" >> $GITHUB_ENV

      - name: Boot ISO and capture visuals
        shell: bash
        run: |
          set -euo pipefail

          mkdir -p artifacts

          # Find OVMF firmware files (prefer non-secureboot for compatibility)
          OVMF_CODE=$(find /usr/share -name "OVMF_CODE*.fd" 2>/dev/null | grep -v snakeoil | grep -v ms | grep -v secboot | head -1)
          if [ -z "$OVMF_CODE" ]; then
            # Fall back to secureboot version if needed
            OVMF_CODE=$(find /usr/share -name "OVMF_CODE*.fd" 2>/dev/null | grep -v snakeoil | grep -v ms | head -1)
          fi
          OVMF_VARS_TEMPLATE=$(find /usr/share -name "OVMF_VARS*.fd" 2>/dev/null | grep -v snakeoil | grep -v ms | head -1)
          echo "Using OVMF_CODE: $OVMF_CODE"
          echo "Using OVMF_VARS template: $OVMF_VARS_TEMPLATE"

          if [ -z "$OVMF_CODE" ] || [ -z "$OVMF_VARS_TEMPLATE" ]; then
            echo "ERROR: OVMF firmware files not found"
            echo "Available OVMF files:"
            find /usr/share -name "OVMF*.fd" 2>/dev/null || true
            exit 1
          fi

          VIDEO_SECONDS=120

          run_boot() {
            local mode=$1
            local vnc_port=$2
            local monitor_socket=$3
            local serial_log=$4
            local prefix=$5
            local iso_path=$6
            shift 6
            local firmware_args=("$@")

            # For EFI boot, use -drive instead of -cdrom for better compatibility
            if [ -n "${firmware_args[*]}" ]; then
              # EFI mode - use drive format for ISO
              qemu-system-x86_64 \
                -m 2048 -smp 2 \
                -device virtio-gpu-pci \
                -display none \
                -vnc :"$vnc_port" \
                -serial file:"$serial_log" \
                -monitor unix:"$monitor_socket",server,nowait \
                -drive file="$iso_path",format=raw,if=none,id=drive-cd,readonly=on \
                -device ahci,id=ahci \
                -device ide-cd,drive=drive-cd,bus=ahci.0 \
                -boot order=d \
                -no-reboot \
                "${firmware_args[@]}" &
            else
              # BIOS mode - use simple cdrom
              qemu-system-x86_64 \
                -m 2048 -smp 2 \
                -device virtio-gpu-pci \
                -display none \
                -vnc :"$vnc_port" \
                -serial file:"$serial_log" \
                -monitor unix:"$monitor_socket",server,nowait \
                -cdrom "$iso_path" \
                -boot d \
                -no-reboot \
                "${firmware_args[@]}" &
            fi

            QEMU_PID=$!

            # Wait for monitor socket
            for i in {1..30}; do
              if [ -S "$monitor_socket" ]; then
                break
              fi
              sleep 1
            done

            # Wait for VNC port
            for i in {1..30}; do
              if (echo > /dev/tcp/127.0.0.1/$((5900 + vnc_port))) >/dev/null 2>&1; then
                break
              fi
              sleep 1
            done

            # Start frame capture loop for video creation (runs in background)
            (
              mkdir -p "artifacts/${prefix}-frames"
              for i in {0..300}; do  # Capture ~60 seconds at 5 FPS
                printf "screendump artifacts/${prefix}-frames/frame%04d.ppm\n" "$i" | socat - UNIX-CONNECT:"$monitor_socket" 2>/dev/null || true
                sleep 0.2  # 5 FPS
              done
            ) &
            CAPTURE_PID=$!

            capture_shot() {
              local name=$1
              printf "screendump artifacts/%s.ppm\n" "$name" | socat - UNIX-CONNECT:"$monitor_socket"
              convert "artifacts/$name.ppm" "artifacts/$name.png"
            }

            # Extended screenshot timing to capture Plymouth boot animation
            # GRUB auto-boots after ~5s, then kernel loads, then Plymouth runs
            sleep 5
            capture_shot "${prefix}-shot1"  # GRUB menu
            sleep 10
            capture_shot "${prefix}-shot2"  # Kernel loading / early Plymouth
            sleep 10
            capture_shot "${prefix}-shot3"  # Plymouth animation
            sleep 10
            capture_shot "${prefix}-shot4"  # Plymouth animation continues
            sleep 10
            capture_shot "${prefix}-shot5"  # Late Plymouth / login screen
            sleep 15
            capture_shot "${prefix}-shot6"  # Post-boot / login screen

            # Brightness check across all screenshots
            mean1=$(convert "artifacts/${prefix}-shot1.png" -colorspace gray -format "%[mean]" info:)
            mean2=$(convert "artifacts/${prefix}-shot2.png" -colorspace gray -format "%[mean]" info:)
            mean3=$(convert "artifacts/${prefix}-shot3.png" -colorspace gray -format "%[mean]" info:)
            mean4=$(convert "artifacts/${prefix}-shot4.png" -colorspace gray -format "%[mean]" info:)
            mean5=$(convert "artifacts/${prefix}-shot5.png" -colorspace gray -format "%[mean]" info:)
            mean6=$(convert "artifacts/${prefix}-shot6.png" -colorspace gray -format "%[mean]" info:)

            echo "$mode shot means: $mean1 $mean2 $mean3 $mean4 $mean5 $mean6"

            is_bright=$(awk -v m1="$mean1" -v m2="$mean2" -v m3="$mean3" -v m4="$mean4" -v m5="$mean5" -v m6="$mean6" 'BEGIN {print ((m1>0.02)||(m2>0.02)||(m3>0.02)||(m4>0.02)||(m5>0.02)||(m6>0.02)) ? 1 : 0}')
            if [ "$is_bright" -ne 1 ]; then
              echo "WARNING: $mode screenshots are too dark. Plymouth may be missing."
            else
              echo "$mode brightness check: PASS"
            fi

            # Shutdown QEMU
            printf "system_powerdown\n" | socat - UNIX-CONNECT:"$monitor_socket" || true
            sleep 3
            kill "$QEMU_PID" || true
            kill "$CAPTURE_PID" 2>/dev/null || true
            
            # Convert captured frames to video
            if [ -d "artifacts/${prefix}-frames" ] && [ "$(ls -A artifacts/${prefix}-frames/*.ppm 2>/dev/null | wc -l)" -gt 0 ]; then
              ffmpeg -y -framerate 5 -pattern_type glob -i "artifacts/${prefix}-frames/*.ppm" \
                -vcodec libx264 -preset fast -crf 23 -pix_fmt yuv420p \
                "artifacts/${prefix}-boot.mp4" 2>/dev/null || echo "Video creation failed for $mode"
              rm -rf "artifacts/${prefix}-frames"  # Clean up frames
            fi
          }

          # BIOS boot test (main ISO)
          run_boot "bios" 1 /tmp/qemu-monitor-bios artifacts/serial-bios.log bios "$ISO_PATH"

          # EFI boot test (main ISO)
          EFI_VARS="/tmp/OVMF_VARS.fd"
          cp "$OVMF_VARS_TEMPLATE" "$EFI_VARS"
          run_boot "efi" 2 /tmp/qemu-monitor-efi artifacts/serial-efi.log efi "$ISO_PATH" \
            -drive if=pflash,format=raw,readonly=on,file="$OVMF_CODE" \
            -drive if=pflash,format=raw,file="$EFI_VARS"

          # EFI boot test (debug ISO with hyper.debug=1)
          EFI_VARS_DEBUG="/tmp/OVMF_VARS_DEBUG.fd"
          cp "$OVMF_VARS_TEMPLATE" "$EFI_VARS_DEBUG"
          run_boot "debug-efi" 3 /tmp/qemu-monitor-debug artifacts/serial-debug-efi.log debug-efi "$ISO_DEBUG_PATH" \
            -drive if=pflash,format=raw,readonly=on,file="$OVMF_CODE" \
            -drive if=pflash,format=raw,file="$EFI_VARS_DEBUG"

      - name: Upload visual artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: visual-smoke
          path: |
            artifacts/bios-shot*.png
            artifacts/efi-shot*.png
            artifacts/debug-efi-shot*.png
            artifacts/*-boot.mp4
            artifacts/serial-*.log
          if-no-files-found: warn

  preview-vm:
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.preview == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 60
    steps:
      - name: Safety notice
        run: |
          echo "Preview mode will expose a temporary public URL via Cloudflare Tunnel." >&2
          echo "Do not use for sensitive data. URL is ephemeral and unauthenticated by default." >&2

      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Install Nix
        uses: cachix/install-nix-action@v27

      - name: Install QEMU + noVNC + cloudflared
        run: |
          set -euo pipefail
          sudo apt-get update
          sudo apt-get install -y qemu-system-x86 qemu-utils ovmf novnc websockify curl

          # Install cloudflared (deb) from GitHub releases to avoid repo availability issues
          CLOUDFLARED_DEB="cloudflared-linux-amd64.deb"
          curl -fsSL -o "$CLOUDFLARED_DEB" https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64.deb
          sudo dpkg -i "$CLOUDFLARED_DEB" || sudo apt-get install -f -y
          cloudflared --version

      - name: Build ISO (main)
        run: |
          set -euo pipefail
          nix build .#packages.x86_64-linux.usb --out-link result-iso --print-build-logs --refresh
          ISO_PATH=$(ls result-iso/iso/*.iso | head -1)
          echo "ISO_PATH=$ISO_PATH" >> $GITHUB_ENV

      - name: Start preview VM with VNC + noVNC + tunnel
        env:
          PREVIEW_DURATION: 1800  # seconds to keep the preview alive (~30m)
        run: |
          set -euo pipefail

          ISO_PATH="$ISO_PATH"

          # Locate firmware
          OVMF_CODE=$(find /usr/share -name "OVMF_CODE*.fd" 2>/dev/null | grep -v snakeoil | grep -v ms | head -1)
          OVMF_VARS_TEMPLATE=$(find /usr/share -name "OVMF_VARS*.fd" 2>/dev/null | grep -v snakeoil | grep -v ms | head -1)
          if [ -z "$OVMF_CODE" ] || [ -z "$OVMF_VARS_TEMPLATE" ]; then
            echo "OVMF firmware not found" >&2
            exit 1
          fi
          EFI_VARS="/tmp/OVMF_VARS_PREVIEW.fd"
          cp "$OVMF_VARS_TEMPLATE" "$EFI_VARS"

          # Start QEMU with QXL VGA (VNC-friendly) on :1 (5901)
          qemu-system-x86_64 \
            -m 2048 -smp 2 \
            -vga qxl \
            -display vnc=:1 \
            -serial stdio \
            -drive file="$ISO_PATH",format=raw,if=none,id=drive-cd,readonly=on \
            -device ahci,id=ahci \
            -device ide-cd,drive=drive-cd,bus=ahci.0 \
            -boot order=d \
            -no-reboot \
            -drive if=pflash,format=raw,readonly=on,file="$OVMF_CODE" \
            -drive if=pflash,format=raw,file="$EFI_VARS" \
            > /tmp/qemu-preview.log 2>&1 &
          QEMU_PID=$!

          # Wait for VNC port
          for i in {1..30}; do
            if (echo > /dev/tcp/127.0.0.1/5901) >/dev/null 2>&1; then
              break
            fi
            sleep 1
          done

          # Launch websockify/noVNC serving on 6080
          NOVNC_DIR="/usr/share/novnc"
          websockify --web="$NOVNC_DIR" 6080 127.0.0.1:5901 > /tmp/websockify.log 2>&1 &
          WSOCK_PID=$!

          # Launch Cloudflare Tunnel (unauthenticated, ephemeral)
          cloudflared tunnel --url http://localhost:6080 --no-autoupdate > /tmp/cloudflared.log 2>&1 &
          CF_PID=$!

          # Wait for URL
          PREVIEW_URL=""
          for i in {1..30}; do
            if grep -Eo 'https://[0-9a-zA-Z.-]+\.trycloudflare\.com' /tmp/cloudflared.log | head -1 >/tmp/preview_url.txt; then
              PREVIEW_URL=$(cat /tmp/preview_url.txt)
              if [ -n "$PREVIEW_URL" ]; then break; fi
            fi
            sleep 1
          done

          if [ -z "$PREVIEW_URL" ]; then
            echo "Failed to obtain Cloudflare Tunnel URL" >&2
            tail -n 50 /tmp/cloudflared.log || true
            exit 1
          fi

          echo "Preview URL: $PREVIEW_URL"
          echo "Open in browser: $PREVIEW_URL/vnc.html?autoconnect=true&resize=scale&path=websockify"

          echo "Preview will stay up for $PREVIEW_DURATION seconds. Press Ctrl+C to end early."
          sleep "$PREVIEW_DURATION"

          kill $CF_PID $WSOCK_PID $QEMU_PID || true

      - name: Upload preview logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: preview-vm-logs
          path: |
            /tmp/qemu-preview.log
            /tmp/websockify.log
            /tmp/cloudflared.log
          if-no-files-found: warn
