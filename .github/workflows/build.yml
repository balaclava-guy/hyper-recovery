name: Fetch, Visual, and Preview

on:
  check_suite:
    types: [completed]
  workflow_dispatch:
    inputs:
      ref:
        description: "Git ref (branch, tag, or commit) to run against"
        required: false
        default: "main"
      mode:
        description: "Run mode"
        required: true
        default: "standard"
        type: choice
        options:
          - standard
          - debug
          - ci-debug-smoke
          - preview
          - preview-debug
          - preview-only
          - preview-only-debug
      preview_duration:
        description: "Seconds to keep the preview tunnel alive"
        required: false
        default: "600"

jobs:
  resolve-options:
    name: Resolve Run Options
    if: |
      github.event_name == 'workflow_dispatch' ||
      (github.event_name == 'check_suite' && github.event.check_suite.app.slug == 'garnix-ci')
    runs-on: ubuntu-latest
    outputs:
      ref: ${{ steps.resolve.outputs.ref }}
      include_debug: ${{ steps.resolve.outputs.include_debug }}
      run_preview: ${{ steps.resolve.outputs.run_preview }}
      preview_debug: ${{ steps.resolve.outputs.preview_debug }}
      ci_debug_smoke: ${{ steps.resolve.outputs.ci_debug_smoke }}
      run_fetch_visual: ${{ steps.resolve.outputs.run_fetch_visual }}
      preview_duration: ${{ steps.resolve.outputs.preview_duration }}
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event_name == 'workflow_dispatch' && inputs.ref || github.event.check_suite.head_sha || github.sha }}

      - name: Resolve options from dispatch mode and commit flags
        id: resolve
        shell: bash
        run: |
          set -euo pipefail

          REF="${{ github.event_name == 'workflow_dispatch' && inputs.ref || github.event.check_suite.head_sha || github.sha }}"
          MODE="${{ github.event_name == 'workflow_dispatch' && inputs.mode || 'standard' }}"
          PREVIEW_DURATION="${{ github.event_name == 'workflow_dispatch' && inputs.preview_duration || '600' }}"

          COMMIT_MESSAGE="$(git log -1 --pretty=%B)"
          COMMIT_MESSAGE_LC="$(printf '%s' "$COMMIT_MESSAGE" | tr '[:upper:]' '[:lower:]')"

          include_debug=false
          run_preview=false
          preview_debug=false
          ci_debug_smoke=false
          run_fetch_visual=true

          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            case "$MODE" in
              standard)
                ;;
              debug)
                include_debug=true
                ;;
              ci-debug-smoke)
                include_debug=true
                ci_debug_smoke=true
                ;;
              preview)
                run_preview=true
                ;;
              preview-debug)
                include_debug=true
                run_preview=true
                preview_debug=true
                ;;
              preview-only)
                run_fetch_visual=false
                run_preview=true
                ;;
              preview-only-debug)
                run_fetch_visual=false
                include_debug=true
                run_preview=true
                preview_debug=true
                ;;
              *)
                echo "::error::Unknown mode: $MODE"
                exit 1
                ;;
            esac
          else
            # Commit-message flags for check_suite-driven runs:
            # [debug], [preview], [preview-debug], [ci-debug]
            if printf '%s' "$COMMIT_MESSAGE_LC" | grep -q '\[debug\]'; then
              include_debug=true
            fi

            if printf '%s' "$COMMIT_MESSAGE_LC" | grep -q '\[preview\]'; then
              run_preview=true
            fi

            if printf '%s' "$COMMIT_MESSAGE_LC" | grep -q '\[preview-debug\]'; then
              include_debug=true
              run_preview=true
              preview_debug=true
            fi

            # [ci-debug] is an alias for [debug] - enables debug artifacts + CI debug log extraction
            if printf '%s' "$COMMIT_MESSAGE_LC" | grep -q '\[ci-debug\]'; then
              include_debug=true
            fi
          fi

          {
            echo "ref=$REF"
            echo "include_debug=$include_debug"
            echo "run_preview=$run_preview"
            echo "preview_debug=$preview_debug"
            echo "ci_debug_smoke=$ci_debug_smoke"
            echo "run_fetch_visual=$run_fetch_visual"
            echo "preview_duration=$PREVIEW_DURATION"
          } >> "$GITHUB_OUTPUT"

          {
            echo "### Run Options"
            echo "- Ref: \`$REF\`"
            if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
              echo "- Dispatch mode: \`$MODE\`"
            else
              echo "- Trigger: \`check_suite\`"
              echo "- Commit flags: \`[debug]\`, \`[preview]\`, \`[preview-debug]\`, \`[ci-debug]\`"
              echo ""
              echo "### Garnix Build"
              echo "- URL: [${{ github.event.check_suite.html_url }}](${{ github.event.check_suite.html_url }})"
            fi
            echo "- include_debug: \`$include_debug\`"
            echo "- run_preview: \`$run_preview\`"
            echo "- preview_debug: \`$preview_debug\`"
            echo "- ci_debug_smoke: \`$ci_debug_smoke\`"
            echo "- run_fetch_visual: \`$run_fetch_visual\`"
            echo "- preview_duration: \`$PREVIEW_DURATION\`"
          } >> "$GITHUB_STEP_SUMMARY"

  fetch-artifacts:
    name: Fetch artifacts
    needs: resolve-options
    if: |
      needs.resolve-options.outputs.run_fetch_visual == 'true' &&
      (
        github.event_name == 'workflow_dispatch' ||
        (
          github.event_name == 'check_suite' &&
          github.event.check_suite.app.slug == 'garnix-ci' &&
          github.event.check_suite.conclusion == 'success'
        )
      )
    runs-on: ubuntu-latest
    timeout-minutes: 15
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.resolve-options.outputs.ref }}

      - name: Install Nix
        uses: cachix/install-nix-action@v27
        with:
          extra_nix_config: |
            substituters = https://cache.nixos.org https://cache.garnix.io
            trusted-public-keys = cache.nixos.org-1:6NCHdD59X431o0gWypbMrAURkbJ16ZPMQFGspcDShjY= cache.garnix.io:CTFPyKSLcx5RMJKfLo5EEPUObbA78b0YQ2DTCJXqr9g=

      - name: Fetch from Cache
        id: fetch-profile
        run: |
          if [ "${{ needs.resolve-options.outputs.include_debug }}" = "true" ]; then
            PKG="image-all-compressed"
            echo "include_debug=true: fetching regular + debug artifacts"
          else
            PKG="image-compressed"
            echo "Fetching regular artifacts only"
          fi

          echo "pkg=$PKG" >> "$GITHUB_OUTPUT"

          echo "::group::Fetching Artifacts"
          echo "Fetching artifacts from Garnix cache for commit $(git rev-parse --short HEAD)..."

          # Build the selected compressed artifacts package.
          # Since Garnix already built this successfully (check_suite=success),
          # regular artifacts should download from cache.garnix.io.
          # We add --refresh to ensure we check the remote cache.
          nix build .#"$PKG" --out-link result-artifacts --print-build-logs --refresh

          echo "::endgroup::"

      - name: Stage Artifacts
        run: |
          mkdir -p dist
          # Find .7z files in the result symlink
          find -L result-artifacts -name "*.7z" -exec cp {} dist/ \;

          echo "Contents of dist/:"
          ls -lh dist/

          count=$(ls dist/*.7z 2>/dev/null | wc -l)
          if [ "$count" -eq 0 ]; then
            echo "::error::No .7z artifacts found in build result!"
            exit 1
          fi
          echo "Found $count artifact(s)."

      # We split the uploads so they appear as separate items in the GitHub UI
      # Note: GitHub Actions *always* wraps artifacts in a .zip file.
      # We use 'compression-level: 0' to speed up this wrapping since our files are already compressed.

      - name: Upload Live ISO
        uses: actions/upload-artifact@v4
        with:
          name: live-iso
          path: dist/hyper-recovery-live.iso.7z
          if-no-files-found: error
          compression-level: 0
          retention-days: 90

      - name: Upload Debug ISO
        uses: actions/upload-artifact@v4
        with:
          name: debug-iso
          path: dist/hyper-recovery-debug.iso.7z
          if-no-files-found: ignore
          compression-level: 0
          retention-days: 90

      - name: Upload VM Image
        uses: actions/upload-artifact@v4
        with:
          name: vm-image
          path: dist/hyper-recovery-vm.qcow2.7z
          if-no-files-found: ignore
          compression-level: 0
          retention-days: 90

  visual:
    name: Visual Test
    needs:
      - resolve-options
      - fetch-artifacts
    if: needs.fetch-artifacts.result == 'success'
    runs-on: ubuntu-latest
    timeout-minutes: 20
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.resolve-options.outputs.ref }}

      - name: Download live ISO artifact
        uses: actions/download-artifact@v4
        with:
          name: live-iso
          path: dist/live

      - name: Download debug ISO artifact (optional)
        if: needs.resolve-options.outputs.include_debug == 'true'
        continue-on-error: true
        uses: actions/download-artifact@v4
        with:
          name: debug-iso
          path: dist/debug

      - name: Install QEMU + Tools
        run: |
          sudo apt-get update
          sudo apt-get install -y qemu-system-x86 qemu-utils socat imagemagick ovmf ffmpeg p7zip-full
          # Verify OVMF path
          ls -la /usr/share/OVMF/ || ls -la /usr/share/ovmf/ || ls -la /usr/share/edk2/
          echo "OVMF files found at:"
          find /usr/share -name "OVMF*.fd" 2>/dev/null | head -5

      - name: Extract ISO artifacts
        run: |
          set -euo pipefail

          LIVE_7Z=$(ls dist/live/*.7z | head -1)
          mkdir -p dist/live/extracted
          7z x "$LIVE_7Z" -odist/live/extracted >/dev/null
          ISO_PATH=$(ls dist/live/extracted/*.iso | head -1)
          echo "ISO_PATH=$ISO_PATH" >> $GITHUB_ENV

          ISO_DEBUG_PATH=""
          if ls dist/debug/*.7z >/dev/null 2>&1; then
            DEBUG_7Z=$(ls dist/debug/*.7z | head -1)
            mkdir -p dist/debug/extracted
            7z x "$DEBUG_7Z" -odist/debug/extracted >/dev/null
            ISO_DEBUG_PATH=$(ls dist/debug/extracted/*.iso | head -1)
          fi
          echo "ISO_DEBUG_PATH=$ISO_DEBUG_PATH" >> $GITHUB_ENV

      - name: Boot ISO and capture visuals
        shell: bash
        env:
          ENABLE_CI_DEBUG: ${{ needs.resolve-options.outputs.include_debug }}
          CI_DEBUG_SMOKE: ${{ needs.resolve-options.outputs.ci_debug_smoke }}
        run: |
          set -euo pipefail

          mkdir -p artifacts
          mkdir -p artifacts/ci-debug

          # Find OVMF firmware files (prefer non-secureboot for compatibility)
          OVMF_CODE=$(find /usr/share -name "OVMF_CODE*.fd" 2>/dev/null | grep -v snakeoil | grep -v ms | grep -v secboot | head -1)
          if [ -z "$OVMF_CODE" ]; then
            # Fall back to secureboot version if needed
            OVMF_CODE=$(find /usr/share -name "OVMF_CODE*.fd" 2>/dev/null | grep -v snakeoil | grep -v ms | head -1)
          fi
          OVMF_VARS_TEMPLATE=$(find /usr/share -name "OVMF_VARS*.fd" 2>/dev/null | grep -v snakeoil | grep -v ms | head -1)
          echo "Using OVMF_CODE: $OVMF_CODE"
          echo "Using OVMF_VARS template: $OVMF_VARS_TEMPLATE"

          if [ -z "$OVMF_CODE" ] || [ -z "$OVMF_VARS_TEMPLATE" ]; then
            echo "ERROR: OVMF firmware files not found"
            echo "Available OVMF files:"
            find /usr/share -name "OVMF*.fd" 2>/dev/null || true
            exit 1
          fi

            run_boot() {
              local mode=$1
              local vnc_port=$2
              local monitor_socket=$3
              local serial_log=$4
              local prefix=$5
              local iso_path=$6
              local expect_ci_debug=$7
              shift 7
              local firmware_args=("$@")

              # Create shared directory for CI debug extraction
              local shared_dir="artifacts/ci-debug-shared-$prefix"
              mkdir -p "$shared_dir"

              # Common QEMU args for virtio-9p shared folder
              local shared_args=(
                -fsdev local,id=fsdev0,path="$shared_dir",security_model=none
                -device virtio-9p-pci,fsdev=fsdev0,mount_tag=ci_debug_share
              )

              # For EFI boot, use -drive instead of -cdrom for better compatibility
              if [ -n "${firmware_args[*]}" ]; then
                # EFI mode - use drive format for ISO
                qemu-system-x86_64 \
                  -m 2048 -smp 2 \
                  -device virtio-gpu-pci \
                  -display none \
                  -vnc :"$vnc_port" \
                  -serial file:"$serial_log" \
                  -monitor unix:"$monitor_socket",server,nowait \
                  -drive file="$iso_path",format=raw,if=none,id=drive-cd,readonly=on \
                  -device ahci,id=ahci \
                  -device ide-cd,drive=drive-cd,bus=ahci.0 \
                  -boot order=d \
                  -no-reboot \
                  "${shared_args[@]}" \
                  "${firmware_args[@]}" &
              else
                # BIOS mode - use simple cdrom
                qemu-system-x86_64 \
                  -m 2048 -smp 2 \
                  -device virtio-gpu-pci \
                  -display none \
                  -vnc :"$vnc_port" \
                  -serial file:"$serial_log" \
                  -monitor unix:"$monitor_socket",server,nowait \
                  -cdrom "$iso_path" \
                  -boot d \
                  -no-reboot \
                  "${shared_args[@]}" \
                  "${firmware_args[@]}" &
              fi

              QEMU_PID=$!

            # Wait for monitor socket
            for i in {1..30}; do
              if [ -S "$monitor_socket" ]; then
                break
              fi
              sleep 1
            done

            # Wait for VNC port
            for i in {1..30}; do
              if (echo > /dev/tcp/127.0.0.1/$((5900 + vnc_port))) >/dev/null 2>&1; then
                break
              fi
              sleep 1
            done

            # Start frame capture loop for video creation (runs in background)
            (
              mkdir -p "artifacts/${prefix}-frames"
              for i in {0..300}; do  # Capture ~60 seconds at 5 FPS
                printf "screendump artifacts/${prefix}-frames/frame%04d.ppm\n" "$i" | socat - UNIX-CONNECT:"$monitor_socket" 2>/dev/null || true
                sleep 0.2  # 5 FPS
              done
            ) &
            CAPTURE_PID=$!

            capture_shot() {
              local name=$1
              printf "screendump artifacts/%s.ppm\n" "$name" | socat - UNIX-CONNECT:"$monitor_socket"
              convert "artifacts/$name.ppm" "artifacts/$name.png"
            }

            extract_ci_debug() {
              local prefix=$1
              
              # Only extract if CI debug is enabled
              if [ "${ENABLE_CI_DEBUG:-false}" != "true" ]; then
                return 0
              fi
              
              echo "Checking for CI debug logs from $prefix VM..."
              
              local shared_dir="artifacts/ci-debug-shared-$prefix"
              
              # Check if any files were written to the shared directory
              if [ -d "$shared_dir" ] && [ "$(ls -A "$shared_dir" 2>/dev/null)" ]; then
                echo "✓ Found CI debug logs from $prefix VM"
                # Copy to final location
                mkdir -p "artifacts/ci-debug/$prefix"
                cp -r "$shared_dir"/* "artifacts/ci-debug/$prefix/" || true
              else
                echo "⚠ No CI debug logs found from $prefix VM (shared folder was empty)"
                echo "  This is expected for non-debug builds or if the service didn't complete"
              fi
            }

            # Extended screenshot timing to capture Plymouth boot animation
            # GRUB auto-boots after ~5s, then kernel loads, then Plymouth runs
            sleep 5
            capture_shot "${prefix}-shot1"  # GRUB menu
            sleep 10
            capture_shot "${prefix}-shot2"  # Kernel loading / early Plymouth
            sleep 10
            capture_shot "${prefix}-shot3"  # Plymouth animation
            sleep 10
            capture_shot "${prefix}-shot4"  # Plymouth animation continues
            sleep 10
            capture_shot "${prefix}-shot5"  # Late Plymouth / login screen
            sleep 15
            capture_shot "${prefix}-shot6"  # Post-boot / login screen

            # Brightness check across all screenshots
            mean1=$(convert "artifacts/${prefix}-shot1.png" -colorspace gray -format "%[mean]" info:)
            mean2=$(convert "artifacts/${prefix}-shot2.png" -colorspace gray -format "%[mean]" info:)
            mean3=$(convert "artifacts/${prefix}-shot3.png" -colorspace gray -format "%[mean]" info:)
            mean4=$(convert "artifacts/${prefix}-shot4.png" -colorspace gray -format "%[mean]" info:)
            mean5=$(convert "artifacts/${prefix}-shot5.png" -colorspace gray -format "%[mean]" info:)
            mean6=$(convert "artifacts/${prefix}-shot6.png" -colorspace gray -format "%[mean]" info:)

            echo "$mode shot means: $mean1 $mean2 $mean3 $mean4 $mean5 $mean6"

            is_bright=$(awk -v m1="$mean1" -v m2="$mean2" -v m3="$mean3" -v m4="$mean4" -v m5="$mean5" -v m6="$mean6" 'BEGIN {print ((m1>0.02)||(m2>0.02)||(m3>0.02)||(m4>0.02)||(m5>0.02)||(m6>0.02)) ? 1 : 0}')
            if [ "$is_bright" -ne 1 ]; then
              echo "WARNING: $mode screenshots are too dark. Plymouth may be missing."
            else
              echo "$mode brightness check: PASS"
            fi

            # Poll for hyper-ci-debug markers only for runs that should include it.
            # This avoids long waits on non-debug VMs and fails faster when startup is broken.
            if [ "$expect_ci_debug" = "true" ]; then
              echo "Polling for hyper-ci-debug markers..."
              local started_file="$shared_dir/.CI_DEBUG_STARTED"
              local complete_file="$shared_dir/.CI_DEBUG_COMPLETE"
              local start_wait=90
              local complete_wait=180
              local waited=0

              while [ ! -f "$started_file" ] && [ $waited -lt $start_wait ]; do
                sleep 5
                waited=$((waited + 5))
              done

              if [ -f "$started_file" ]; then
                echo "✓ CI debug start marker found after ${waited}s"

                waited=0
                while [ ! -f "$complete_file" ] && [ $waited -lt $complete_wait ]; do
                  sleep 5
                  waited=$((waited + 5))
                  if [ $((waited % 30)) -eq 0 ]; then
                    echo "  Still waiting for completion... (${waited}s/${complete_wait}s)"
                  fi
                done

                if [ -f "$complete_file" ]; then
                  echo "✓ CI debug completion marker found after ${waited}s"
                else
                  echo "⚠ CI debug completion marker not found after ${complete_wait}s"
                  echo "  Check serial log and service status in extracted debug bundle"
                fi
              else
                echo "⚠ CI debug start marker not found after ${start_wait}s"
                echo "  Service likely did not start or shared folder mount failed"
              fi
            fi

            # Shutdown QEMU
            printf "system_powerdown\n" | socat - UNIX-CONNECT:"$monitor_socket" || true
            sleep 3
            kill "$QEMU_PID" || true
            kill "$CAPTURE_PID" 2>/dev/null || true

            # Convert captured frames to video
            if [ -d "artifacts/${prefix}-frames" ] && [ "$(ls -A artifacts/${prefix}-frames/*.ppm 2>/dev/null | wc -l)" -gt 0 ]; then
              ffmpeg -y -framerate 5 -pattern_type glob -i "artifacts/${prefix}-frames/*.ppm" \
                -vcodec libx264 -preset fast -crf 23 -pix_fmt yuv420p \
                "artifacts/${prefix}-boot.mp4" 2>/dev/null || echo "Video creation failed for $mode"
              rm -rf "artifacts/${prefix}-frames"  # Clean up frames
            fi
          }

          if [ "${CI_DEBUG_SMOKE:-false}" != "true" ]; then
            # BIOS boot test (main ISO)
            run_boot "bios" 1 /tmp/qemu-monitor-bios artifacts/serial-bios.log bios "$ISO_PATH" false
            extract_ci_debug "bios"

            # EFI boot test (main ISO)
            EFI_VARS="/tmp/OVMF_VARS.fd"
            cp "$OVMF_VARS_TEMPLATE" "$EFI_VARS"
            run_boot "efi" 2 /tmp/qemu-monitor-efi artifacts/serial-efi.log efi "$ISO_PATH" false \
              -drive if=pflash,format=raw,readonly=on,file="$OVMF_CODE" \
              -drive if=pflash,format=raw,file="$EFI_VARS"
            extract_ci_debug "efi"
          else
            echo "CI debug smoke mode enabled: skipping BIOS and EFI regular ISO boots"
          fi

          # EFI boot test (debug ISO) when available
          if [ -n "${ISO_DEBUG_PATH:-}" ] && [ -f "$ISO_DEBUG_PATH" ]; then
            EFI_VARS_DEBUG="/tmp/OVMF_VARS_DEBUG.fd"
            cp "$OVMF_VARS_TEMPLATE" "$EFI_VARS_DEBUG"
            run_boot "debug-efi" 3 /tmp/qemu-monitor-debug artifacts/serial-debug-efi.log debug-efi "$ISO_DEBUG_PATH" "${ENABLE_CI_DEBUG:-false}" \
              -drive if=pflash,format=raw,readonly=on,file="$OVMF_CODE" \
              -drive if=pflash,format=raw,file="$EFI_VARS_DEBUG"
            extract_ci_debug "debug-efi"
          else
            echo "No debug ISO artifact found; skipping debug EFI boot test."
          fi

      - name: Upload visual artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: visual
          path: |
            artifacts/bios-shot*.png
            artifacts/efi-shot*.png
            artifacts/debug-efi-shot*.png
            artifacts/*-boot.mp4
            artifacts/serial-*.log
          if-no-files-found: warn

      - name: Upload CI debug logs
        if: always() && needs.resolve-options.outputs.include_debug == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: ci-debug-logs
          path: artifacts/ci-debug/
          if-no-files-found: error

  preview-vm:
    name: Preview VM
    needs: [resolve-options, fetch-artifacts]
    if: needs.resolve-options.outputs.run_preview == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 60
    permissions:
      contents: read
      deployments: write
    steps:
      - name: Safety notice
        run: |
          echo "Preview exposes a temporary public URL via Cloudflare Tunnel." >&2
          echo "Do not use for sensitive data. URL is ephemeral and unauthenticated by default." >&2

      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.resolve-options.outputs.ref }}

      - name: Install system dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y qemu-system-x86 qemu-utils ovmf novnc websockify curl lsof p7zip-full

      - name: Download live ISO artifact
        if: ${{ needs.resolve-options.outputs.preview_debug != 'true' }}
        uses: actions/download-artifact@v4
        with:
          name: live-iso
          path: dist

      - name: Download debug ISO artifact
        if: ${{ needs.resolve-options.outputs.preview_debug == 'true' }}
        uses: actions/download-artifact@v4
        with:
          name: debug-iso
          path: dist

      - name: Extract ISO
        run: |
          set -euo pipefail

          # Extract the .7z archive
          if ls dist/*.7z >/dev/null 2>&1; then
            ARCHIVE=$(ls dist/*.7z | head -1)
            7z x "$ARCHIVE" -odist/ >/dev/null
            rm "$ARCHIVE"
          fi

          # Find the ISO file
          ISO_PATH=$(find dist -type f -name '*.iso' | head -1)

          if [ -z "$ISO_PATH" ]; then
            echo "::error::Could not find ISO file in artifact"
            exit 1
          fi

          echo "ISO_PATH=$ISO_PATH" >> $GITHUB_ENV
          echo "::notice::Using ISO: $ISO_PATH"

      - name: Install cloudflared
        run: |
          CLOUDFLARED_DEB="cloudflared-linux-amd64.deb"
          curl -fsSL -o "$CLOUDFLARED_DEB" https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64.deb
          sudo dpkg -i "$CLOUDFLARED_DEB" || sudo apt-get install -f -y
          cloudflared --version

      - name: Start preview VM with VNC + noVNC + tunnel
        env:
          PREVIEW_DURATION: ${{ needs.resolve-options.outputs.preview_duration }}
        run: |
          set -euo pipefail

          ISO_PATH="$ISO_PATH"

          # Locate firmware (match visual logic: prefer non-secureboot)
          OVMF_CODE=$(find /usr/share -name "OVMF_CODE*.fd" 2>/dev/null | grep -v snakeoil | grep -v ms | grep -v secboot | head -1)
          if [ -z "$OVMF_CODE" ]; then
            OVMF_CODE=$(find /usr/share -name "OVMF_CODE*.fd" 2>/dev/null | grep -v snakeoil | grep -v ms | head -1)
          fi
          OVMF_VARS_TEMPLATE=$(find /usr/share -name "OVMF_VARS*.fd" 2>/dev/null | grep -v snakeoil | grep -v ms | head -1)
          if [ -z "$OVMF_CODE" ] || [ -z "$OVMF_VARS_TEMPLATE" ]; then
            echo "OVMF firmware not found" >&2
            exit 1
          fi
          EFI_VARS="/tmp/OVMF_VARS_PREVIEW.fd"
          cp "$OVMF_VARS_TEMPLATE" "$EFI_VARS"

          # Start QEMU with virtio-gpu-pci (matching visual job)
          qemu-system-x86_64 \
            -m 2048 -smp 2 \
            -device virtio-gpu-pci \
            -display none \
            -vnc :1 \
            -serial file:/tmp/qemu-serial.log \
            -drive file="$ISO_PATH",format=raw,if=none,id=drive-cd,readonly=on \
            -device ahci,id=ahci \
            -device ide-cd,drive=drive-cd,bus=ahci.0 \
            -boot order=d \
            -drive if=pflash,format=raw,readonly=on,file="$OVMF_CODE" \
            -drive if=pflash,format=raw,file="$EFI_VARS" \
            > /tmp/qemu-preview.log 2>&1 &
          QEMU_PID=$!

          # Wait for VNC port
          for i in {1..30}; do
            if (echo > /dev/tcp/127.0.0.1/5901) >/dev/null 2>&1; then
              break
            fi
            sleep 1
          done

          # Launch websockify/noVNC serving on 6080
          NOVNC_DIR="/usr/share/novnc"
          websockify --web="$NOVNC_DIR" 6080 127.0.0.1:5901 > /tmp/websockify.log 2>&1 &
          WSOCK_PID=$!

          # Launch Cloudflare Tunnel (unauthenticated, ephemeral) with retries
          PREVIEW_URL=""
          for attempt in {1..5}; do
            : > /tmp/cloudflared.log
            cloudflared tunnel --url http://localhost:6080 --no-autoupdate > /tmp/cloudflared.log 2>&1 &
            CF_PID=$!

            for i in {1..30}; do
              if grep -Eo 'https://[0-9a-zA-Z.-]+\.trycloudflare\.com' /tmp/cloudflared.log | head -1 >/tmp/preview_url.txt; then
                PREVIEW_URL=$(cat /tmp/preview_url.txt)
                if [ -n "$PREVIEW_URL" ]; then break; fi
              fi
              sleep 1
            done

            if [ -n "$PREVIEW_URL" ]; then
              break
            fi

            echo "cloudflared attempt $attempt failed; retrying..." >&2
            kill $CF_PID || true
            sleep 2
          done

          if [ -z "$PREVIEW_URL" ]; then
            echo "Failed to obtain Cloudflare Tunnel URL after retries" >&2
            tail -n 50 /tmp/cloudflared.log || true
            exit 1
          fi

          echo "Preview URL: $PREVIEW_URL"
          echo "Open in browser: $PREVIEW_URL/vnc.html?autoconnect=true&resize=scale&path=websockify" | tee -a $GITHUB_STEP_SUMMARY
          echo "$PREVIEW_URL/vnc.html?autoconnect=true&resize=scale&path=websockify" > preview-url.txt

          echo "Preview will stay up for $PREVIEW_DURATION seconds or until the viewer disconnects (idle timeout)."

          IDLE_TIMEOUT=${IDLE_TIMEOUT:-300}
          deadline=$(( $(date +%s) + PREVIEW_DURATION ))
          no_client_since=$(date +%s)

          while true; do
            now=$(date +%s)
            if [ $now -ge $deadline ]; then
              echo "Reached preview deadline ($PREVIEW_DURATION s). Exiting."
              break
            fi

            # Detect active VNC client (websockify -> qemu VNC)
            if lsof -iTCP:5901 -sTCP:ESTABLISHED 2>/dev/null | tail -n +2 | grep -q .; then
              no_client_since=$now
            else
              idle_for=$(( now - no_client_since ))
              if [ $idle_for -ge $IDLE_TIMEOUT ]; then
                echo "No viewer for ${IDLE_TIMEOUT}s; exiting early."
                break
              fi
            fi

            # Exit early if QEMU died
            if ! kill -0 $QEMU_PID 2>/dev/null; then
              echo "QEMU exited; stopping preview."
              break
            fi

            sleep 3
          done

          kill $CF_PID $WSOCK_PID $QEMU_PID || true

      - name: Upload preview logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: preview-vm-logs
          path: |
            /tmp/qemu-preview.log
            /tmp/qemu-serial.log
            /tmp/websockify.log
            /tmp/cloudflared.log
            preview-url.txt
          if-no-files-found: warn
