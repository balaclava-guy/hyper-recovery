#!/usr/bin/env python3

from __future__ import annotations

import argparse
import hashlib
import os
import platform
import shutil
import socket
import subprocess
import sys
import textwrap
import time
import urllib.request
from pathlib import Path


def _which(p: str) -> str | None:
    return shutil.which(p)


def _run(cmd: list[str], *, check: bool = True) -> subprocess.CompletedProcess[str]:
    return subprocess.run(cmd, check=check, text=True)


def _sha256_file(p: Path) -> str:
    h = hashlib.sha256()
    with p.open("rb") as f:
        for chunk in iter(lambda: f.read(1024 * 1024), b""):
            h.update(chunk)
    return h.hexdigest()


def _download(url: str, dest: Path) -> None:
    dest.parent.mkdir(parents=True, exist_ok=True)
    tmp = dest.with_suffix(dest.suffix + ".tmp")
    req = urllib.request.Request(url, headers={"User-Agent": "hyper-theme-vm/1.0"})
    with urllib.request.urlopen(req) as r, tmp.open("wb") as f:
        total = r.headers.get("Content-Length")
        total_i = int(total) if total and total.isdigit() else None
        done = 0
        last = time.time()
        while True:
            buf = r.read(1024 * 1024)
            if not buf:
                break
            f.write(buf)
            done += len(buf)
            now = time.time()
            if total_i and now - last > 0.5:
                pct = (done / total_i) * 100.0
                sys.stderr.write(f"\rDownloading base image: {pct:5.1f}%")
                sys.stderr.flush()
                last = now
    if total_i:
        sys.stderr.write("\rDownloading base image: 100.0%\n")
    tmp.replace(dest)


def _find_firmware(search_roots: list[Path]) -> tuple[Path, Path | None] | None:
    # Common AArch64 UEFI firmware naming patterns.
    code_patterns = [
        "edk2-aarch64-code.fd",
        "QEMU_EFI.fd",
        "QEMU_EFI_CODE.fd",
        "AAVMF_CODE.fd",
    ]
    vars_patterns = [
        "edk2-aarch64-vars.fd",
        "QEMU_EFI_VARS.fd",
        "AAVMF_VARS.fd",
    ]
    loose_code = ("aarch64", "code", ".fd")
    loose_vars = ("aarch64", "vars", ".fd")

    def walk_find(patterns: list[str], loose: tuple[str, str, str]) -> Path | None:
        for root in search_roots:
            if not root.exists():
                continue
            for name in patterns:
                p = root / name
                if p.is_file():
                    return p
            max_files = 20000
            seen = 0
            for dirpath, _, filenames in os.walk(root):
                for fn in filenames:
                    seen += 1
                    if seen > max_files:
                        break
                    lf = fn.lower()
                    if loose[0] in lf and loose[1] in lf and lf.endswith(loose[2]):
                        p = Path(dirpath) / fn
                        if p.is_file():
                            return p
                if seen > max_files:
                    break
        return None

    code = walk_find(code_patterns, loose_code)
    vars_ = walk_find(vars_patterns, loose_vars)
    if code:
        return (code, vars_)
    return None


def _make_cloud_init_seed_iso(xorriso: str, seed_dir: Path, out_iso: Path) -> None:
    out_iso.parent.mkdir(parents=True, exist_ok=True)
    if out_iso.exists():
        out_iso.unlink()
    _run(
        [
            xorriso,
            "-as",
            "mkisofs",
            "-V",
            "CIDATA",
            "-o",
            str(out_iso),
            "-J",
            "-r",
            str(seed_dir),
        ]
    )


def _write_cloud_init(seed_dir: Path) -> None:
    seed_dir.mkdir(parents=True, exist_ok=True)
    (seed_dir / "meta-data").write_text(
        textwrap.dedent(
            """\
            instance-id: hyper-theme-vm
            local-hostname: hyper-theme-vm
            """
        ),
        encoding="utf-8",
    )

    (seed_dir / "user-data").write_text(
        textwrap.dedent(
            """\
            #cloud-config
            ssh_pwauth: true
            disable_root: false
            users:
              - name: theme
                groups: [sudo]
                sudo: ALL=(ALL) NOPASSWD:ALL
                shell: /bin/bash
                lock_passwd: false
            chpasswd:
              expire: false
              list: |
                theme:theme

            write_files:
              - path: /usr/local/sbin/hyper-theme-sync
                permissions: '0755'
                content: |
                  #!/usr/bin/env bash
                  set -euo pipefail

                  state_dir=/var/lib/hyper-theme-sync
                  mkdir -p "$state_dir"
                  stamp="$state_dir/last.sha256"

                  find_theme_dev() {
                    while IFS= read -r dev; do
                      mnt="$(mktemp -d)"
                      if mount -t vfat -o ro "$dev" "$mnt" 2>/dev/null; then
                        if [[ -f "$mnt/THEME_SYNC_MARKER" ]]; then
                          echo "$dev"
                          umount "$mnt" || true
                          rmdir "$mnt" || true
                          return 0
                        fi
                        umount "$mnt" || true
                      fi
                      rmdir "$mnt" || true
                    done < <(lsblk -pnro NAME,FSTYPE,TYPE | awk '$2=="vfat"{print $1}')
                    return 1
                  }

                  dev="$(find_theme_dev || true)"
                  if [[ -z "${dev:-}" ]]; then
                    echo "hyper-theme-sync: no theme drive found; skipping" >&2
                    exit 0
                  fi

                  mnt=/mnt/hyper-theme
                  mkdir -p "$mnt"
                  mount -t vfat -o ro "$dev" "$mnt"
                  trap 'umount "$mnt" 2>/dev/null || true' EXIT

                  hold_seconds="$(cat "$mnt/HOLD_SECONDS" 2>/dev/null || echo 8)"
                  if ! [[ "$hold_seconds" =~ ^[0-9]+$ ]]; then hold_seconds=8; fi

                  grub_timeout="$(cat "$mnt/GRUB_TIMEOUT" 2>/dev/null || echo 15)"
                  if ! [[ "$grub_timeout" =~ ^-?[0-9]+$ ]]; then grub_timeout=15; fi

                  new_sha="$(
                    (
                      cd "$mnt"
                      find themes/grub/hyper-recovery themes/plymouth/hyper-recovery assets/fonts/undefined-medium -type f -print0 \
                        | LC_ALL=C sort -z \
                        | xargs -0 sha256sum
                      printf "hold_seconds=%s\ngrub_timeout=%s\n" "$hold_seconds" "$grub_timeout"
                    ) | sha256sum | awk '{print $1}'
                  )"

                  old_sha="$(cat "$stamp" 2>/dev/null || true)"
                  if [[ -n "$old_sha" && "$old_sha" == "$new_sha" ]]; then
                    echo "hyper-theme-sync: no changes" >&2
                    exit 0
                  fi

                  echo "hyper-theme-sync: applying theme update..." >&2

                  if ! command -v grub-mkfont >/dev/null 2>&1 || \
                     ! command -v update-grub >/dev/null 2>&1 || \
                     ! command -v plymouth-set-default-theme >/dev/null 2>&1; then
                    export DEBIAN_FRONTEND=noninteractive
                    apt-get update -y
                    apt-get install -y grub-efi-arm64 grub-common plymouth plymouth-themes
                  fi

                  grub_theme_dir=/boot/grub/themes/snosu-hyper-recovery
                  rm -rf "$grub_theme_dir"
                  mkdir -p "$grub_theme_dir"
                  cp -R "$mnt/themes/grub/hyper-recovery/"* "$grub_theme_dir/"

                  font_src="$mnt/assets/fonts/undefined-medium/undefined-medium.ttf"
                  grub-mkfont -s 12 -o "$grub_theme_dir/undefined_medium_12.pf2" "$font_src"
                  grub-mkfont -s 14 -o "$grub_theme_dir/undefined_medium_14.pf2" "$font_src"
                  grub-mkfont -s 16 -o "$grub_theme_dir/undefined_medium_16.pf2" "$font_src"
                  grub-mkfont -s 24 -o "$grub_theme_dir/undefined_medium_24.pf2" "$font_src"
                  grub-mkfont -s 28 -o "$grub_theme_dir/undefined_medium_28.pf2" "$font_src"

                  sed -i 's/Hyper Street Fighter 2 Regular/Undefined Medium/g' "$grub_theme_dir/theme.txt" || true
                  sed -i 's/Hyper Fighting Regular/Undefined Medium/g' "$grub_theme_dir/theme.txt" || true

                  grub_defaults=/etc/default/grub
                  # Ensure GRUB is in graphical mode so the theme can render.
                  sed -i '/^GRUB_TERMINAL=/d' "$grub_defaults" 2>/dev/null || true

                  if ! grep -q '^GRUB_TIMEOUT_STYLE=' "$grub_defaults" 2>/dev/null; then
                    echo 'GRUB_TIMEOUT_STYLE=menu' >> "$grub_defaults"
                  else
                    sed -i 's/^GRUB_TIMEOUT_STYLE=.*/GRUB_TIMEOUT_STYLE=menu/' "$grub_defaults"
                  fi
                  if ! grep -q '^GRUB_TIMEOUT=' "$grub_defaults" 2>/dev/null; then
                    echo "GRUB_TIMEOUT=$grub_timeout" >> "$grub_defaults"
                  else
                    sed -i "s/^GRUB_TIMEOUT=.*/GRUB_TIMEOUT=$grub_timeout/" "$grub_defaults"
                  fi

                  if grep -q '^GRUB_GFXMODE=' "$grub_defaults" 2>/dev/null; then
                    sed -i 's/^GRUB_GFXMODE=.*/GRUB_GFXMODE=auto/' "$grub_defaults"
                  else
                    echo 'GRUB_GFXMODE=auto' >> "$grub_defaults"
                  fi
                  if grep -q '^GRUB_GFXPAYLOAD_LINUX=' "$grub_defaults" 2>/dev/null; then
                    sed -i 's/^GRUB_GFXPAYLOAD_LINUX=.*/GRUB_GFXPAYLOAD_LINUX=keep/' "$grub_defaults"
                  else
                    echo 'GRUB_GFXPAYLOAD_LINUX=keep' >> "$grub_defaults"
                  fi
                  if grep -q '^GRUB_TERMINAL_OUTPUT=' "$grub_defaults" 2>/dev/null; then
                    sed -i 's/^GRUB_TERMINAL_OUTPUT=.*/GRUB_TERMINAL_OUTPUT=gfxterm/' "$grub_defaults"
                  else
                    echo 'GRUB_TERMINAL_OUTPUT=gfxterm' >> "$grub_defaults"
                  fi

                  # Make sure Plymouth is actually used.
                  if grep -q '^GRUB_CMDLINE_LINUX_DEFAULT=' "$grub_defaults" 2>/dev/null; then
                    sed -i 's/^GRUB_CMDLINE_LINUX_DEFAULT=.*/GRUB_CMDLINE_LINUX_DEFAULT="quiet splash plymouth.ignore-serial-consoles"/' "$grub_defaults"
                  else
                    echo 'GRUB_CMDLINE_LINUX_DEFAULT="quiet splash plymouth.ignore-serial-consoles"' >> "$grub_defaults"
                  fi

                  if grep -q '^GRUB_THEME=' "$grub_defaults" 2>/dev/null; then
                    sed -i "s|^GRUB_THEME=.*|GRUB_THEME=${grub_theme_dir}/theme.txt|" "$grub_defaults"
                  else
                    echo "GRUB_THEME=${grub_theme_dir}/theme.txt" >> "$grub_defaults"
                  fi
                  update-grub

                  # Keep Plymouth visible for theme iteration: delay plymouth-quit.
                  mkdir -p /etc/systemd/system/plymouth-quit.service.d
                  cat > /etc/systemd/system/plymouth-quit.service.d/hyper-hold.conf <<EOF
[Service]
ExecStartPre=/usr/bin/sleep $hold_seconds
EOF
                  systemctl daemon-reload || true

                  ply_theme_dir=/usr/share/plymouth/themes/snosu-hyper-recovery
                  rm -rf "$ply_theme_dir"
                  mkdir -p "$ply_theme_dir"
                  cp -R "$mnt/themes/plymouth/hyper-recovery/"* "$ply_theme_dir/"
                  cp "$font_src" "$ply_theme_dir/undefined-medium.ttf" || true

                  if [[ -f "$ply_theme_dir/snosu-hyper-recovery.plymouth" ]]; then
                    sed -i "s|^ImageDir=.*|ImageDir=${ply_theme_dir}|" "$ply_theme_dir/snosu-hyper-recovery.plymouth" || true
                  fi
                  plymouth-set-default-theme -R snosu-hyper-recovery

                  echo "$new_sha" > "$stamp"
                  sync || true

                  echo "hyper-theme-sync: done; rebooting to show Plymouth theme..." >&2
                  systemctl reboot

              - path: /etc/systemd/system/hyper-theme-sync.service
                permissions: '0644'
                content: |
                  [Unit]
                  Description=Hyper theme sync (GRUB + Plymouth)
                  After=network-online.target
                  Wants=network-online.target

                  [Service]
                  Type=oneshot
                  ExecStart=/usr/local/sbin/hyper-theme-sync

                  [Install]
                  WantedBy=multi-user.target

            runcmd:
              - [ systemctl, daemon-reload ]
              - [ systemctl, enable, --now, hyper-theme-sync.service ]
            """
        ),
        encoding="utf-8",
    )


def _write_nixos_module(dest: Path) -> None:
    dest.parent.mkdir(parents=True, exist_ok=True)
    dest.write_text(
        textwrap.dedent(
            """\
            # Minimal NixOS module to apply the GRUB + Plymouth themes from /etc/hyper-theme-src.
            #
            # /etc/nixos/hyper-theme-settings.nix is managed by hyper-theme-sync and should contain:
            #   { holdSeconds = 8; grubTimeout = 15; }
            { config, lib, pkgs, ... }:

            let
              settingsPath = /etc/nixos/hyper-theme-settings.nix;
              settings =
                if builtins.pathExists settingsPath
                then import settingsPath
                else { holdSeconds = 8; grubTimeout = 15; };

              holdSeconds = settings.holdSeconds or 8;
              grubTimeout = settings.grubTimeout or 15;

              themeSrc = /etc/hyper-theme-src;

              grubTheme = pkgs.stdenvNoCC.mkDerivation {
                pname = "snosu-hyper-recovery-grub-theme";
                version = "0";
                src = themeSrc;
                nativeBuildInputs = [ pkgs.grub2 pkgs.gnused ];
                installPhase = ''
                  set -euo pipefail
                  mkdir -p "$out"
                  cp -R "themes/grub/hyper-recovery/"* "$out/"

                  font_src="$src/assets/fonts/undefined-medium/undefined-medium.ttf"
                  ${pkgs.grub2}/bin/grub-mkfont -s 12 -o "$out/undefined_medium_12.pf2" "$font_src"
                  ${pkgs.grub2}/bin/grub-mkfont -s 14 -o "$out/undefined_medium_14.pf2" "$font_src"
                  ${pkgs.grub2}/bin/grub-mkfont -s 16 -o "$out/undefined_medium_16.pf2" "$font_src"
                  ${pkgs.grub2}/bin/grub-mkfont -s 24 -o "$out/undefined_medium_24.pf2" "$font_src"
                  ${pkgs.grub2}/bin/grub-mkfont -s 28 -o "$out/undefined_medium_28.pf2" "$font_src"

                  sed -i 's/Hyper Street Fighter 2 Regular/Undefined Medium/g' "$out/theme.txt" || true
                  sed -i 's/Hyper Fighting Regular/Undefined Medium/g' "$out/theme.txt" || true
                '';
              };

              plymouthTheme = pkgs.stdenvNoCC.mkDerivation {
                pname = "snosu-hyper-recovery-plymouth-theme";
                version = "0";
                src = themeSrc;
                nativeBuildInputs = [ pkgs.gnused ];
                installPhase = ''
                  set -euo pipefail
                  mkdir -p "$out/share/plymouth/themes/snosu-hyper-recovery"
                  dest="$out/share/plymouth/themes/snosu-hyper-recovery"
                  cp -R "themes/plymouth/hyper-recovery/"* "$dest/"
                  cp "$src/assets/fonts/undefined-medium/undefined-medium.ttf" "$dest/undefined-medium.ttf" || true

                  if [ -f "$dest/snosu-hyper-recovery.plymouth" ]; then
                    sed -i "s|^ImageDir=.*|ImageDir=$dest|" "$dest/snosu-hyper-recovery.plymouth" || true
                  fi
                '';
              };

              hyperThemeSync = pkgs.writeShellScript "hyper-theme-sync" ''
                set -euo pipefail

                state_dir=/var/lib/hyper-theme-sync
                mkdir -p "$state_dir"
                stamp="$state_dir/last.sha256"

                find_theme_dev() {
                  while IFS= read -r dev; do
                    mnt="$(mktemp -d)"
                    if ${pkgs.util-linux}/bin/mount -t vfat -o ro "$dev" "$mnt" 2>/dev/null; then
                      if [ -f "$mnt/THEME_SYNC_MARKER" ]; then
                        echo "$dev"
                        ${pkgs.util-linux}/bin/umount "$mnt" || true
                        rmdir "$mnt" || true
                        return 0
                      fi
                      ${pkgs.util-linux}/bin/umount "$mnt" || true
                    fi
                    rmdir "$mnt" || true
                  done < <(${pkgs.util-linux}/bin/lsblk -pnro NAME,FSTYPE,TYPE | ${pkgs.gawk}/bin/awk '$2=="vfat"{print $1}')
                  return 1
                }

                dev="$(find_theme_dev || true)"
                if [ -z "${dev:-}" ]; then
                  echo "hyper-theme-sync: no theme drive found; skipping" >&2
                  exit 0
                fi

                mnt=/mnt/hyper-theme
                mkdir -p "$mnt"
                ${pkgs.util-linux}/bin/mount -t vfat -o ro "$dev" "$mnt"
                trap '${pkgs.util-linux}/bin/umount "$mnt" 2>/dev/null || true' EXIT

                hold_seconds="$(${pkgs.coreutils}/bin/cat "$mnt/HOLD_SECONDS" 2>/dev/null || echo 8)"
                if ! [[ "$hold_seconds" =~ ^[0-9]+$ ]]; then hold_seconds=8; fi

                grub_timeout="$(${pkgs.coreutils}/bin/cat "$mnt/GRUB_TIMEOUT" 2>/dev/null || echo 15)"
                if ! [[ "$grub_timeout" =~ ^-?[0-9]+$ ]]; then grub_timeout=15; fi

                new_sha="$(
                  (
                    cd "$mnt"
                    ${pkgs.findutils}/bin/find themes/grub/hyper-recovery themes/plymouth/hyper-recovery assets/fonts/undefined-medium -type f -print0 \
                      | LC_ALL=C ${pkgs.coreutils}/bin/sort -z \
                      | ${pkgs.findutils}/bin/xargs -0 ${pkgs.coreutils}/bin/sha256sum
                    printf "hold_seconds=%s\ngrub_timeout=%s\n" "$hold_seconds" "$grub_timeout"
                  ) | ${pkgs.coreutils}/bin/sha256sum | ${pkgs.gawk}/bin/awk '{print $1}'
                )"

                old_sha="$(${pkgs.coreutils}/bin/cat "$stamp" 2>/dev/null || true)"
                if [ -n "$old_sha" ] && [ "$old_sha" = "$new_sha" ]; then
                  echo "hyper-theme-sync: no changes" >&2
                  exit 0
                fi

                echo "hyper-theme-sync: syncing theme sources..." >&2
                ${pkgs.coreutils}/bin/rm -rf /etc/hyper-theme-src
                ${pkgs.coreutils}/bin/mkdir -p /etc/hyper-theme-src
                ${pkgs.coreutils}/bin/cp -R "$mnt/themes" /etc/hyper-theme-src/
                ${pkgs.coreutils}/bin/cp -R "$mnt/assets" /etc/hyper-theme-src/

                # Feed settings into the module via a simple import file.
                ${pkgs.coreutils}/bin/printf '{ holdSeconds = %s; grubTimeout = %s; }\\n' \
                  "$hold_seconds" "$grub_timeout" > /etc/nixos/hyper-theme-settings.nix

                echo "hyper-theme-sync: rebuilding boot config..." >&2
                /run/current-system/sw/bin/nixos-rebuild boot --fast

                ${pkgs.coreutils}/bin/echo "$new_sha" > "$stamp"
                ${pkgs.coreutils}/bin/sync || true

                echo "hyper-theme-sync: done; rebooting to show themes..." >&2
                /run/current-system/sw/bin/systemctl reboot
              '';
            in
            {
              # Make sure GRUB is used (so we can preview the GRUB theme).
              boot.loader.systemd-boot.enable = false;
              boot.loader.efi.canTouchEfiVariables = true;
              boot.loader.efi.efiSysMountPoint = "/boot";

              boot.loader.grub = {
                enable = true;
                efiSupport = true;
                device = "nodev";
                efiInstallAsRemovable = true;
                theme = grubTheme;

                # We'll override GRUB's real timeout via extraConfig; keep a non-negative value here.
                timeout = 1;

                extraConfig = ''
                  set timeout_style=menu
                  set timeout=${if grubTimeout < 0 then "-1" else toString grubTimeout}

                  insmod all_video
                  insmod gfxterm
                  terminal_output gfxterm
                  set gfxmode=auto
                '';
              };

              boot.kernelParams = [ "quiet" "splash" "plymouth.ignore-serial-consoles" ];

              boot.plymouth.enable = true;
              boot.plymouth.theme = "snosu-hyper-recovery";
              boot.plymouth.themePackages = [ plymouthTheme ];

              # Keep Plymouth visible for theme iteration.
              environment.etc."systemd/system/plymouth-quit.service.d/hyper-hold.conf".text = ''
                [Service]
                ExecStartPre=${pkgs.coreutils}/bin/sleep ${toString holdSeconds}
              '';

              # Run on each boot; if the theme tree changed, rebuild boot assets and reboot.
              systemd.services.hyper-theme-sync = {
                description = "Hyper theme sync (GRUB + Plymouth)";
                wantedBy = [ "multi-user.target" ];
                after = [ "network-online.target" ];
                wants = [ "network-online.target" ];
                serviceConfig = {
                  Type = "oneshot";
                  ExecStart = hyperThemeSync;
                };
              };

              # Give the sync service the tools it expects.
              environment.systemPackages = [
                pkgs.util-linux
                pkgs.findutils
                pkgs.gawk
                pkgs.gnused
              ];
            }
            """
        ),
        encoding="utf-8",
    )


def _write_nixos_install_script(dest: Path) -> None:
    dest.write_text(
        textwrap.dedent(
            """\
            #!/usr/bin/env bash
            set -euo pipefail

            disk=/dev/vda

            find_theme_dev() {
              while IFS= read -r dev; do
                mnt="$(mktemp -d)"
                if mount -t vfat -o ro "$dev" "$mnt" 2>/dev/null; then
                  if [ -f "$mnt/THEME_SYNC_MARKER" ]; then
                    echo "$dev"
                    umount "$mnt" || true
                    rmdir "$mnt" || true
                    return 0
                  fi
                  umount "$mnt" || true
                fi
                rmdir "$mnt" || true
              done < <(lsblk -pnro NAME,FSTYPE,TYPE | awk '$2=="vfat"{print $1}')
              return 1
            }

            if [ "$(id -u)" -ne 0 ]; then
              echo "Re-running as root (sudo)..." >&2
              exec sudo -E "$0" "$@"
            fi

            if [ ! -b "$disk" ]; then
              echo "Expected install disk $disk to exist. (Did QEMU attach the virtio disk?)" >&2
              exit 1
            fi

            dev="$(find_theme_dev || true)"
            if [ -z "${dev:-}" ]; then
              echo "Could not locate the theme drive (vfat) containing THEME_SYNC_MARKER." >&2
              echo "Make sure theme-vm attached the FAT share drive." >&2
              exit 1
            fi

            theme_mnt=/tmp/hyper-theme
            mkdir -p "$theme_mnt"
            mount -t vfat -o ro "$dev" "$theme_mnt"
            trap 'umount "$theme_mnt" 2>/dev/null || true' EXIT

            hold_seconds="$(cat "$theme_mnt/HOLD_SECONDS" 2>/dev/null || echo 8)"
            if ! [[ "$hold_seconds" =~ ^[0-9]+$ ]]; then hold_seconds=8; fi

            grub_timeout="$(cat "$theme_mnt/GRUB_TIMEOUT" 2>/dev/null || echo 15)"
            if ! [[ "$grub_timeout" =~ ^-?[0-9]+$ ]]; then grub_timeout=15; fi

            state_version="$(nixos-version 2>/dev/null | cut -d. -f1-2)"
            if ! [[ "$state_version" =~ ^[0-9]+\\.[0-9]+$ ]]; then
              state_version="24.11"
            fi

            echo "Installing NixOS to $disk (stateVersion=$state_version)..." >&2

            set +e
            umount /mnt/boot 2>/dev/null
            umount /mnt 2>/dev/null
            set -e

            parted -s "$disk" -- mklabel gpt
            parted -s "$disk" -- mkpart ESP fat32 1MiB 512MiB
            parted -s "$disk" -- set 1 esp on
            parted -s "$disk" -- mkpart primary ext4 512MiB 100%

            mkfs.fat -F 32 "${disk}1"
            mkfs.ext4 -F "${disk}2"

            mount "${disk}2" /mnt
            mkdir -p /mnt/boot
            mount "${disk}1" /mnt/boot

            nixos-generate-config --root /mnt

            mkdir -p /mnt/etc/nixos
            cp "$theme_mnt/nixos/hyper-theme.nix" /mnt/etc/nixos/hyper-theme.nix

            cat > /mnt/etc/nixos/hyper-theme-settings.nix <<EOF
            { holdSeconds = $hold_seconds; grubTimeout = $grub_timeout; }
            EOF

            cat > /mnt/etc/nixos/configuration.nix <<EOF
            { config, pkgs, ... }:
            {
              imports = [
                ./hardware-configuration.nix
                ./hyper-theme.nix
              ];

              networking.hostName = "hyper-theme-vm";
              time.timeZone = "UTC";

              users.users.theme = {
                isNormalUser = true;
                extraGroups = [ "wheel" ];
                initialPassword = "theme";
              };
              security.sudo.wheelNeedsPassword = false;

              services.openssh.enable = true;
              services.openssh.settings.PasswordAuthentication = true;
              services.openssh.settings.PermitRootLogin = "no";

              nix.settings.experimental-features = [ "nix-command" "flakes" ];

              system.stateVersion = "$state_version";
            }
            EOF

            rm -rf /mnt/etc/hyper-theme-src
            mkdir -p /mnt/etc/hyper-theme-src
            cp -R "$theme_mnt/themes" /mnt/etc/hyper-theme-src/
            cp -R "$theme_mnt/assets" /mnt/etc/hyper-theme-src/

            nixos-install --no-root-passwd

            echo "Install complete. Rebooting..." >&2
            reboot
            """
        ),
        encoding="utf-8",
    )
    dest.chmod(0o755)


def _write_nixos_install_readme(dest: Path) -> None:
    dest.write_text(
        textwrap.dedent(
            """\
            NixOS install (one-time)
            =======================

            This VM base boots a minimal NixOS aarch64 ISO and installs to the attached virtio disk.
            The installer script is on this FAT share drive:

              hyper-nixos-install

            In the NixOS installer environment, run:

              sudo -i
              mkdir -p /mnt/theme
              for dev in $(lsblk -pnro NAME,FSTYPE,TYPE | awk '$2=="vfat"{print $1}'); do
                mount -t vfat -o ro "$dev" /mnt/theme 2>/dev/null || continue
                if [ -f /mnt/theme/THEME_SYNC_MARKER ]; then
                  break
                fi
                umount /mnt/theme 2>/dev/null || true
              done
              bash /mnt/theme/hyper-nixos-install

            After install, re-run:

              nix run .#theme-vm -- --base nixos
            """
        ),
        encoding="utf-8",
    )


def _host_is_darwin_arm64() -> bool:
    return sys.platform == "darwin" and platform.machine() == "arm64"


def main() -> int:
    p = argparse.ArgumentParser(
        prog="theme-vm",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        description=textwrap.dedent(
            """\
            Minimal local theme preview VM.

            On macOS arm64: boots an Ubuntu ARM64 cloud VM in QEMU+HVF, syncs this repo's
            GRUB/Plymouth themes into it, and reboots once when changes are detected.

            You can also use a minimal NixOS aarch64 ISO as the base to get a more realistic
            (NixOS) boot pipeline. First run will require installing NixOS inside the VM.
            """
        ),
    )
    p.add_argument(
        "--fresh",
        action="store_true",
        help="Recreate cached VM state (Ubuntu overlay, NixOS disk, seed ISO, UEFI vars)",
    )
    p.add_argument("--headless", action="store_true", help="Run QEMU with -nographic")
    p.add_argument("--ssh", action="store_true", help="Print SSH command (localhost:2222)")
    p.add_argument(
        "--ssh-port",
        type=int,
        default=2222,
        help="Host port to forward to guest SSH (default: 2222). Use 0 to disable forwarding.",
    )
    p.add_argument(
        "--hold-seconds",
        type=int,
        default=8,
        help="How long to keep Plymouth visible by delaying plymouth-quit (default: 8)",
    )
    p.add_argument(
        "--grub-timeout",
        type=int,
        default=15,
        help="GRUB menu timeout in seconds (default: 15)",
    )
    p.add_argument("--repo", default=".", help="Path to the hyper-recovery repo (defaults to current directory)")
    p.add_argument("--cache-dir", default=os.environ.get("HYPER_THEME_VM_DIR", ""), help="Cache dir override")
    p.add_argument(
        "--base",
        choices=["ubuntu", "nixos"],
        default=os.environ.get("HYPER_THEME_VM_BASE", "ubuntu"),
        help="Guest base to use (default: ubuntu). 'nixos' boots a minimal NixOS aarch64 ISO and installs to a cached disk.",
    )
    p.add_argument(
        "--base-image",
        default=os.environ.get("HYPER_THEME_BASE_IMG", ""),
        help="Path to a pre-downloaded Ubuntu ARM64 cloud image (skips download)",
    )
    p.add_argument(
        "--ubuntu-url",
        default=os.environ.get(
            "UBUNTU_CLOUDIMG_URL",
            "https://cloud-images.ubuntu.com/noble/current/noble-server-cloudimg-arm64.img",
        ),
        help="Ubuntu cloud image URL (arm64)",
    )
    p.add_argument(
        "--nixos-url",
        default=os.environ.get(
            "NIXOS_MINIMAL_ISO_URL",
            "https://channels.nixos.org/nixos-unstable/latest-nixos-minimal-aarch64-linux.iso",
        ),
        help="NixOS minimal ISO URL (aarch64-linux)",
    )
    p.add_argument(
        "--nixos-install",
        action="store_true",
        help="Attach the NixOS installer ISO even if a cached NixOS disk exists",
    )
    args = p.parse_args()

    if not _host_is_darwin_arm64():
        sys.stderr.write("theme-vm currently supports macOS arm64 only.\n")
        return 2

    repo = Path(args.repo).resolve()
    if not (repo / "themes/grub/hyper-recovery/theme.txt").is_file():
        sys.stderr.write(f"Repo path does not look like hyper-recovery: {repo}\n")
        sys.stderr.write("Expected to find: themes/grub/hyper-recovery/theme.txt\n")
        return 2

    # Default to /tmp because this is safe in sandboxed environments (Codex) and
    # avoids permissions surprises under ~/Library or ~/.cache on macOS.
    cache_dir = Path(args.cache_dir) if args.cache_dir else Path("/tmp/hyper-theme-vm")
    cache_dir.mkdir(parents=True, exist_ok=True)

    os.environ.setdefault("XDG_CACHE_HOME", str(cache_dir / "xdg-cache"))
    Path(os.environ["XDG_CACHE_HOME"]).mkdir(parents=True, exist_ok=True)

    share_dir = cache_dir / "share"
    seed_dir = cache_dir / "seed"
    seed_iso = cache_dir / "seed.iso"
    base_img = cache_dir / "ubuntu-base.img"
    overlay_img = cache_dir / "ubuntu-overlay.qcow2"
    nixos_iso = cache_dir / "nixos-minimal-aarch64.iso"
    nixos_disk = cache_dir / "nixos-disk.qcow2"
    uefi_vars = cache_dir / "uefi-vars.fd"

    # These tokens are replaced by Nix in the flake package.
    qemu_system = os.environ.get("QEMU_SYSTEM_AARCH64", "@qemu_system_aarch64@")
    qemu_img = os.environ.get("QEMU_IMG", "@qemu_img@")
    xorriso = os.environ.get("XORRISO", "@xorriso@")
    firmware_roots_raw = os.environ.get("FIRMWARE_SEARCH_DIRS", "@firmware_search_dirs@")

    # If the flake didn't substitute these tokens (or you're running the repo script
    # directly), fall back to PATH lookup.
    if qemu_system.startswith("@"):
        qemu_system = _which("qemu-system-aarch64") or ""
    if qemu_img.startswith("@"):
        qemu_img = _which("qemu-img") or ""
    if xorriso.startswith("@"):
        xorriso = _which("xorriso") or ""
    if firmware_roots_raw.startswith("@"):
        firmware_roots_raw = ""

    if not qemu_system:
        sys.stderr.write("Missing qemu-system-aarch64 in PATH (or QEMU_SYSTEM_AARCH64 not set).\n")
        return 1
    if not qemu_img:
        sys.stderr.write("Missing qemu-img in PATH (or QEMU_IMG not set).\n")
        return 1
    if not xorriso:
        sys.stderr.write("Missing xorriso in PATH (or XORRISO not set).\n")
        return 1

    firmware_search_dirs: list[Path] = []
    if firmware_roots_raw and "@firmware_search_dirs@" not in firmware_roots_raw:
        for part in firmware_roots_raw.split(":"):
            if part.strip():
                firmware_search_dirs.append(Path(part.strip()))

    qemu_share = Path(qemu_system).resolve().parent.parent / "share" / "qemu"
    firmware_search_dirs.append(qemu_share)
    firmware_search_dirs.append(Path("/opt/homebrew/share/qemu"))

    def port_free(port: int) -> bool:
        if port <= 0:
            return False
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            try:
                s.bind(("127.0.0.1", port))
            except OSError:
                return False
            return True

    ssh_port = args.ssh_port
    if ssh_port != 0 and not port_free(ssh_port):
        # Avoid failing hard if another VM instance is still running.
        for cand in range(ssh_port + 1, ssh_port + 50):
            if port_free(cand):
                ssh_port = cand
                break
        else:
            sys.stderr.write("No free port found for SSH forwarding; disabling SSH forwarding.\n")
            ssh_port = 0

    if args.ssh and ssh_port != 0:
        sys.stderr.write(
            "SSH (after first boot): ssh -o StrictHostKeyChecking=no "
            "-o UserKnownHostsFile=/dev/null -p "
            f"{ssh_port} theme@127.0.0.1\n"
        )

    if args.fresh:
        for pth in (overlay_img, seed_iso, uefi_vars, nixos_disk):
            if pth.exists():
                pth.unlink()

    if share_dir.exists():
        shutil.rmtree(share_dir)
    (share_dir / "themes/grub").mkdir(parents=True, exist_ok=True)
    (share_dir / "themes/plymouth").mkdir(parents=True, exist_ok=True)
    (share_dir / "assets/fonts/undefined-medium").mkdir(parents=True, exist_ok=True)
    (share_dir / "THEME_SYNC_MARKER").write_text("hyper-theme-sync\n", encoding="utf-8")
    (share_dir / "HOLD_SECONDS").write_text(f"{args.hold_seconds}\n", encoding="utf-8")
    (share_dir / "GRUB_TIMEOUT").write_text(f"{args.grub_timeout}\n", encoding="utf-8")

    shutil.copytree(repo / "themes/grub/hyper-recovery", share_dir / "themes/grub/hyper-recovery")
    shutil.copytree(repo / "themes/plymouth/hyper-recovery", share_dir / "themes/plymouth/hyper-recovery")
    shutil.copy2(
        repo / "assets/fonts/undefined-medium/undefined-medium.ttf",
        share_dir / "assets/fonts/undefined-medium/undefined-medium.ttf",
    )

    # NixOS base helper files (used only when --base nixos).
    _write_nixos_module(share_dir / "nixos" / "hyper-theme.nix")
    _write_nixos_install_script(share_dir / "hyper-nixos-install")
    _write_nixos_install_readme(share_dir / "README-NIXOS-INSTALL.txt")

    efi_code_env = os.environ.get("HYPER_THEME_EFI_CODE", "")
    efi_vars_env = os.environ.get("HYPER_THEME_EFI_VARS", "")
    efi_code: Path
    efi_vars_src: Path | None
    if efi_code_env:
        efi_code = Path(efi_code_env)
        if not efi_code.is_file():
            sys.stderr.write("HYPER_THEME_EFI_CODE was set but file does not exist.\n")
            return 1
        efi_vars_src = Path(efi_vars_env) if efi_vars_env else None
        if efi_vars_src and not efi_vars_src.is_file():
            sys.stderr.write("HYPER_THEME_EFI_VARS was set but file does not exist.\n")
            return 1
    else:
        fw = _find_firmware(firmware_search_dirs)
        if not fw:
            sys.stderr.write(
                "Failed to locate AArch64 UEFI firmware code (.fd). "
                "Provide HYPER_THEME_EFI_CODE (and optionally HYPER_THEME_EFI_VARS).\n"
            )
            return 1
        efi_code, efi_vars_src = fw

    # Some QEMU builds ship edk2 AArch64 code but not an AArch64 vars template.
    # In that case, prefer an ARM vars template if present; otherwise create a blank vars file.
    if efi_vars_src is None:
        for d in firmware_search_dirs:
            cand = d / "edk2-arm-vars.fd"
            if cand.is_file():
                efi_vars_src = cand
                break

    if not uefi_vars.exists():
        if efi_vars_src and efi_vars_src.is_file():
            shutil.copy2(efi_vars_src, uefi_vars)
        else:
            # 64 MiB vars (matches typical edk2 fd sizes in nixpkgs qemu share dir).
            uefi_vars.write_bytes(b"\0" * (64 * 1024 * 1024))
    # QEMU must be able to write UEFI variables.
    try:
        uefi_vars.chmod(0o600)
    except PermissionError:
        pass

    netdev = "user,id=net0"
    if ssh_port != 0:
        netdev = f"user,id=net0,hostfwd=tcp:127.0.0.1:{ssh_port}-:22"

    qemu_args = [
        qemu_system,
        "-machine",
        "virt,accel=hvf,highmem=off",
        "-cpu",
        "host",
        "-m",
        "2048",
        "-smp",
        "2",
        "-device",
        "qemu-xhci",
        "-device",
        "usb-kbd",
        "-device",
        "usb-mouse",
        "-device",
        "virtio-gpu-pci",
        "-netdev",
        netdev,
        "-device",
        "virtio-net-pci,netdev=net0",
        "-drive",
        f"if=pflash,format=raw,readonly=on,file={efi_code}",
        "-drive",
        f"if=pflash,format=raw,file={uefi_vars}",
    ]

    if args.base == "ubuntu":
        if args.base_image:
            src = Path(args.base_image).expanduser().resolve()
            if not src.is_file():
                sys.stderr.write(f"--base-image does not exist: {src}\n")
                return 2
            if not base_img.exists() or _sha256_file(base_img) != _sha256_file(src):
                shutil.copy2(src, base_img)
        elif not base_img.exists():
            sys.stderr.write(f"Downloading Ubuntu cloud image: {args.ubuntu_url}\n")
            _download(args.ubuntu_url, base_img)

        _write_cloud_init(seed_dir)
        _make_cloud_init_seed_iso(xorriso, seed_dir, seed_iso)

        if not overlay_img.exists():
            _run([qemu_img, "create", "-f", "qcow2", "-F", "qcow2", "-b", str(base_img), str(overlay_img)])

        qemu_args.extend(
            [
                "-drive",
                f"if=virtio,format=qcow2,file={overlay_img}",
                "-drive",
                f"if=virtio,format=raw,media=cdrom,file={seed_iso}",
            ]
        )
    else:
        # NixOS base: a one-time install from a minimal ISO into a cached qcow2 disk.
        if not nixos_iso.exists():
            sys.stderr.write(f"Downloading NixOS minimal ISO: {args.nixos_url}\n")
            _download(args.nixos_url, nixos_iso)

        install_mode = args.nixos_install or (not nixos_disk.exists())
        if not nixos_disk.exists():
            sys.stderr.write("Creating NixOS disk image (16G)...\n")
            _run([qemu_img, "create", "-f", "qcow2", str(nixos_disk), "16G"])
        if install_mode:
            sys.stderr.write(
                "\nNixOS install mode:\n"
                "1) In the NixOS installer VM, run: sudo -i\n"
                "2) Follow README-NIXOS-INSTALL.txt on the theme drive and run: hyper-nixos-install\n\n"
            )

        qemu_args.extend(
            [
                "-drive",
                f"if=virtio,format=qcow2,file={nixos_disk}",
            ]
        )
        if install_mode:
            qemu_args.extend(
                [
                    "-boot",
                    "order=d",
                    "-drive",
                    f"if=virtio,format=raw,media=cdrom,file={nixos_iso}",
                ]
            )

    # Attach the theme share last so it doesn't become /dev/vda.
    qemu_args.extend(["-drive", f"if=virtio,format=raw,file=fat:rw:{share_dir}"])

    if args.headless:
        qemu_args.append("-nographic")

    os.execv(qemu_system, qemu_args)
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
