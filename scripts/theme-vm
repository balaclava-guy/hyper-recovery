#!/usr/bin/env python3

from __future__ import annotations

import argparse
import hashlib
import os
import platform
import shutil
import socket
import subprocess
import sys
import textwrap
import time
import urllib.request
from pathlib import Path


def _which(p: str) -> str | None:
    return shutil.which(p)


def _run(cmd: list[str], *, check: bool = True) -> subprocess.CompletedProcess[str]:
    return subprocess.run(cmd, check=check, text=True)


def _sha256_file(p: Path) -> str:
    h = hashlib.sha256()
    with p.open("rb") as f:
        for chunk in iter(lambda: f.read(1024 * 1024), b""):
            h.update(chunk)
    return h.hexdigest()


def _download(url: str, dest: Path) -> None:
    dest.parent.mkdir(parents=True, exist_ok=True)
    tmp = dest.with_suffix(dest.suffix + ".tmp")
    req = urllib.request.Request(url, headers={"User-Agent": "hyper-theme-vm/1.0"})
    with urllib.request.urlopen(req) as r, tmp.open("wb") as f:
        total = r.headers.get("Content-Length")
        total_i = int(total) if total and total.isdigit() else None
        done = 0
        last = time.time()
        while True:
            buf = r.read(1024 * 1024)
            if not buf:
                break
            f.write(buf)
            done += len(buf)
            now = time.time()
            if total_i and now - last > 0.5:
                pct = (done / total_i) * 100.0
                sys.stderr.write(f"\rDownloading base image: {pct:5.1f}%")
                sys.stderr.flush()
                last = now
    if total_i:
        sys.stderr.write("\rDownloading base image: 100.0%\n")
    tmp.replace(dest)


def _find_firmware(search_roots: list[Path]) -> tuple[Path, Path | None] | None:
    # Common AArch64 UEFI firmware naming patterns.
    code_patterns = [
        "edk2-aarch64-code.fd",
        "QEMU_EFI.fd",
        "QEMU_EFI_CODE.fd",
        "AAVMF_CODE.fd",
    ]
    vars_patterns = [
        "edk2-aarch64-vars.fd",
        "QEMU_EFI_VARS.fd",
        "AAVMF_VARS.fd",
    ]
    loose_code = ("aarch64", "code", ".fd")
    loose_vars = ("aarch64", "vars", ".fd")

    def walk_find(patterns: list[str], loose: tuple[str, str, str]) -> Path | None:
        for root in search_roots:
            if not root.exists():
                continue
            for name in patterns:
                p = root / name
                if p.is_file():
                    return p
            max_files = 20000
            seen = 0
            for dirpath, _, filenames in os.walk(root):
                for fn in filenames:
                    seen += 1
                    if seen > max_files:
                        break
                    lf = fn.lower()
                    if loose[0] in lf and loose[1] in lf and lf.endswith(loose[2]):
                        p = Path(dirpath) / fn
                        if p.is_file():
                            return p
                if seen > max_files:
                    break
        return None

    code = walk_find(code_patterns, loose_code)
    vars_ = walk_find(vars_patterns, loose_vars)
    if code:
        return (code, vars_)
    return None


def _make_cloud_init_seed_iso(xorriso: str, seed_dir: Path, out_iso: Path) -> None:
    out_iso.parent.mkdir(parents=True, exist_ok=True)
    if out_iso.exists():
        out_iso.unlink()
    _run(
        [
            xorriso,
            "-as",
            "mkisofs",
            "-V",
            "CIDATA",
            "-o",
            str(out_iso),
            "-J",
            "-r",
            str(seed_dir),
        ]
    )


def _write_cloud_init(seed_dir: Path) -> None:
    seed_dir.mkdir(parents=True, exist_ok=True)
    (seed_dir / "meta-data").write_text(
        textwrap.dedent(
            """\
            instance-id: hyper-theme-vm
            local-hostname: hyper-theme-vm
            """
        ),
        encoding="utf-8",
    )

    (seed_dir / "user-data").write_text(
        textwrap.dedent(
            """\
            #cloud-config
            ssh_pwauth: true
            disable_root: false
            users:
              - name: theme
                groups: [sudo]
                sudo: ALL=(ALL) NOPASSWD:ALL
                shell: /bin/bash
                lock_passwd: false
            chpasswd:
              expire: false
              list: |
                theme:theme

            write_files:
              - path: /usr/local/sbin/hyper-theme-sync
                permissions: '0755'
                content: |
                  #!/usr/bin/env bash
                  set -euo pipefail

                  state_dir=/var/lib/hyper-theme-sync
                  mkdir -p "$state_dir"
                  stamp="$state_dir/last.sha256"

                  find_theme_dev() {
                    while IFS= read -r dev; do
                      mnt="$(mktemp -d)"
                      if mount -t vfat -o ro "$dev" "$mnt" 2>/dev/null; then
                        if [[ -f "$mnt/THEME_SYNC_MARKER" ]]; then
                          echo "$dev"
                          umount "$mnt" || true
                          rmdir "$mnt" || true
                          return 0
                        fi
                        umount "$mnt" || true
                      fi
                      rmdir "$mnt" || true
                    done < <(lsblk -pnro NAME,FSTYPE,TYPE | awk '$2=="vfat"{print $1}')
                    return 1
                  }

                  dev="$(find_theme_dev || true)"
                  if [[ -z "${dev:-}" ]]; then
                    echo "hyper-theme-sync: no theme drive found; skipping" >&2
                    exit 0
                  fi

                  mnt=/mnt/hyper-theme
                  mkdir -p "$mnt"
                  mount -t vfat -o ro "$dev" "$mnt"
                  trap 'umount "$mnt" 2>/dev/null || true' EXIT

                  hold_seconds="$(cat "$mnt/HOLD_SECONDS" 2>/dev/null || echo 8)"
                  if ! [[ "$hold_seconds" =~ ^[0-9]+$ ]]; then hold_seconds=8; fi

                  grub_timeout="$(cat "$mnt/GRUB_TIMEOUT" 2>/dev/null || echo 15)"
                  if ! [[ "$grub_timeout" =~ ^-?[0-9]+$ ]]; then grub_timeout=15; fi

                  new_sha="$(
                    (
                      cd "$mnt"
                      find themes/grub/hyper-recovery themes/plymouth/hyper-recovery assets/fonts/undefined-medium -type f -print0 \
                        | LC_ALL=C sort -z \
                        | xargs -0 sha256sum
                      printf "hold_seconds=%s\ngrub_timeout=%s\n" "$hold_seconds" "$grub_timeout"
                    ) | sha256sum | awk '{print $1}'
                  )"

                  old_sha="$(cat "$stamp" 2>/dev/null || true)"
                  if [[ -n "$old_sha" && "$old_sha" == "$new_sha" ]]; then
                    echo "hyper-theme-sync: no changes" >&2
                    exit 0
                  fi

                  echo "hyper-theme-sync: applying theme update..." >&2

                  if ! command -v grub-mkfont >/dev/null 2>&1 || \
                     ! command -v update-grub >/dev/null 2>&1 || \
                     ! command -v plymouth-set-default-theme >/dev/null 2>&1; then
                    export DEBIAN_FRONTEND=noninteractive
                    apt-get update -y
                    apt-get install -y grub-efi-arm64 grub-common plymouth plymouth-themes
                  fi

                  grub_theme_dir=/boot/grub/themes/snosu-hyper-recovery
                  rm -rf "$grub_theme_dir"
                  mkdir -p "$grub_theme_dir"
                  cp -R "$mnt/themes/grub/hyper-recovery/"* "$grub_theme_dir/"

                  font_src="$mnt/assets/fonts/undefined-medium/undefined-medium.ttf"
                  grub-mkfont -s 12 -o "$grub_theme_dir/undefined_medium_12.pf2" "$font_src"
                  grub-mkfont -s 14 -o "$grub_theme_dir/undefined_medium_14.pf2" "$font_src"
                  grub-mkfont -s 16 -o "$grub_theme_dir/undefined_medium_16.pf2" "$font_src"
                  grub-mkfont -s 24 -o "$grub_theme_dir/undefined_medium_24.pf2" "$font_src"
                  grub-mkfont -s 28 -o "$grub_theme_dir/undefined_medium_28.pf2" "$font_src"

                  sed -i 's/Hyper Street Fighter 2 Regular/Undefined Medium/g' "$grub_theme_dir/theme.txt" || true
                  sed -i 's/Hyper Fighting Regular/Undefined Medium/g' "$grub_theme_dir/theme.txt" || true

                  grub_defaults=/etc/default/grub
                  # Ensure GRUB is in graphical mode so the theme can render.
                  sed -i '/^GRUB_TERMINAL=/d' "$grub_defaults" 2>/dev/null || true

                  if ! grep -q '^GRUB_TIMEOUT_STYLE=' "$grub_defaults" 2>/dev/null; then
                    echo 'GRUB_TIMEOUT_STYLE=menu' >> "$grub_defaults"
                  else
                    sed -i 's/^GRUB_TIMEOUT_STYLE=.*/GRUB_TIMEOUT_STYLE=menu/' "$grub_defaults"
                  fi
                  if ! grep -q '^GRUB_TIMEOUT=' "$grub_defaults" 2>/dev/null; then
                    echo "GRUB_TIMEOUT=$grub_timeout" >> "$grub_defaults"
                  else
                    sed -i "s/^GRUB_TIMEOUT=.*/GRUB_TIMEOUT=$grub_timeout/" "$grub_defaults"
                  fi

                  if grep -q '^GRUB_GFXMODE=' "$grub_defaults" 2>/dev/null; then
                    sed -i 's/^GRUB_GFXMODE=.*/GRUB_GFXMODE=auto/' "$grub_defaults"
                  else
                    echo 'GRUB_GFXMODE=auto' >> "$grub_defaults"
                  fi
                  if grep -q '^GRUB_GFXPAYLOAD_LINUX=' "$grub_defaults" 2>/dev/null; then
                    sed -i 's/^GRUB_GFXPAYLOAD_LINUX=.*/GRUB_GFXPAYLOAD_LINUX=keep/' "$grub_defaults"
                  else
                    echo 'GRUB_GFXPAYLOAD_LINUX=keep' >> "$grub_defaults"
                  fi
                  if grep -q '^GRUB_TERMINAL_OUTPUT=' "$grub_defaults" 2>/dev/null; then
                    sed -i 's/^GRUB_TERMINAL_OUTPUT=.*/GRUB_TERMINAL_OUTPUT=gfxterm/' "$grub_defaults"
                  else
                    echo 'GRUB_TERMINAL_OUTPUT=gfxterm' >> "$grub_defaults"
                  fi

                  # Make sure Plymouth is actually used.
                  if grep -q '^GRUB_CMDLINE_LINUX_DEFAULT=' "$grub_defaults" 2>/dev/null; then
                    sed -i 's/^GRUB_CMDLINE_LINUX_DEFAULT=.*/GRUB_CMDLINE_LINUX_DEFAULT="quiet splash plymouth.ignore-serial-consoles"/' "$grub_defaults"
                  else
                    echo 'GRUB_CMDLINE_LINUX_DEFAULT="quiet splash plymouth.ignore-serial-consoles"' >> "$grub_defaults"
                  fi

                  if grep -q '^GRUB_THEME=' "$grub_defaults" 2>/dev/null; then
                    sed -i "s|^GRUB_THEME=.*|GRUB_THEME=${grub_theme_dir}/theme.txt|" "$grub_defaults"
                  else
                    echo "GRUB_THEME=${grub_theme_dir}/theme.txt" >> "$grub_defaults"
                  fi
                  update-grub

                  # Keep Plymouth visible for theme iteration: delay plymouth-quit.
                  mkdir -p /etc/systemd/system/plymouth-quit.service.d
                  cat > /etc/systemd/system/plymouth-quit.service.d/hyper-hold.conf <<EOF
[Service]
ExecStartPre=/usr/bin/sleep $hold_seconds
EOF
                  systemctl daemon-reload || true

                  ply_theme_dir=/usr/share/plymouth/themes/snosu-hyper-recovery
                  rm -rf "$ply_theme_dir"
                  mkdir -p "$ply_theme_dir"
                  cp -R "$mnt/themes/plymouth/hyper-recovery/"* "$ply_theme_dir/"
                  cp "$font_src" "$ply_theme_dir/undefined-medium.ttf" || true

                  if [[ -f "$ply_theme_dir/snosu-hyper-recovery.plymouth" ]]; then
                    sed -i "s|^ImageDir=.*|ImageDir=${ply_theme_dir}|" "$ply_theme_dir/snosu-hyper-recovery.plymouth" || true
                  fi
                  plymouth-set-default-theme -R snosu-hyper-recovery

                  echo "$new_sha" > "$stamp"
                  sync || true

                  echo "hyper-theme-sync: done; rebooting to show Plymouth theme..." >&2
                  systemctl reboot

              - path: /etc/systemd/system/hyper-theme-sync.service
                permissions: '0644'
                content: |
                  [Unit]
                  Description=Hyper theme sync (GRUB + Plymouth)
                  After=network-online.target
                  Wants=network-online.target

                  [Service]
                  Type=oneshot
                  ExecStart=/usr/local/sbin/hyper-theme-sync

                  [Install]
                  WantedBy=multi-user.target

            runcmd:
              - [ systemctl, daemon-reload ]
              - [ systemctl, enable, --now, hyper-theme-sync.service ]
            """
        ),
        encoding="utf-8",
    )


def _host_is_darwin_arm64() -> bool:
    return sys.platform == "darwin" and platform.machine() == "arm64"


def main() -> int:
    p = argparse.ArgumentParser(
        prog="theme-vm",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        description=textwrap.dedent(
            """\
            Minimal local theme preview VM.

            On macOS arm64: boots an Ubuntu ARM64 cloud VM in QEMU+HVF, syncs this repo's
            GRUB/Plymouth themes into it, and reboots once when changes are detected.
            """
        ),
    )
    p.add_argument("--fresh", action="store_true", help="Recreate overlay disk and seed ISO")
    p.add_argument("--headless", action="store_true", help="Run QEMU with -nographic")
    p.add_argument("--ssh", action="store_true", help="Print SSH command (localhost:2222)")
    p.add_argument(
        "--ssh-port",
        type=int,
        default=2222,
        help="Host port to forward to guest SSH (default: 2222). Use 0 to disable forwarding.",
    )
    p.add_argument(
        "--hold-seconds",
        type=int,
        default=8,
        help="How long to keep Plymouth visible by delaying plymouth-quit (default: 8)",
    )
    p.add_argument(
        "--grub-timeout",
        type=int,
        default=15,
        help="GRUB menu timeout in seconds (default: 15)",
    )
    p.add_argument("--repo", default=".", help="Path to the hyper-recovery repo (defaults to current directory)")
    p.add_argument("--cache-dir", default=os.environ.get("HYPER_THEME_VM_DIR", ""), help="Cache dir override")
    p.add_argument(
        "--base-image",
        default=os.environ.get("HYPER_THEME_BASE_IMG", ""),
        help="Path to a pre-downloaded Ubuntu ARM64 cloud image (skips download)",
    )
    p.add_argument(
        "--ubuntu-url",
        default=os.environ.get(
            "UBUNTU_CLOUDIMG_URL",
            "https://cloud-images.ubuntu.com/noble/current/noble-server-cloudimg-arm64.img",
        ),
        help="Ubuntu cloud image URL (arm64)",
    )
    args = p.parse_args()

    if not _host_is_darwin_arm64():
        sys.stderr.write("theme-vm currently supports macOS arm64 only.\n")
        return 2

    repo = Path(args.repo).resolve()
    if not (repo / "themes/grub/hyper-recovery/theme.txt").is_file():
        sys.stderr.write(f"Repo path does not look like hyper-recovery: {repo}\n")
        sys.stderr.write("Expected to find: themes/grub/hyper-recovery/theme.txt\n")
        return 2

    # Default to /tmp because this is safe in sandboxed environments (Codex) and
    # avoids permissions surprises under ~/Library or ~/.cache on macOS.
    cache_dir = Path(args.cache_dir) if args.cache_dir else Path("/tmp/hyper-theme-vm")
    cache_dir.mkdir(parents=True, exist_ok=True)

    os.environ.setdefault("XDG_CACHE_HOME", str(cache_dir / "xdg-cache"))
    Path(os.environ["XDG_CACHE_HOME"]).mkdir(parents=True, exist_ok=True)

    share_dir = cache_dir / "share"
    seed_dir = cache_dir / "seed"
    seed_iso = cache_dir / "seed.iso"
    base_img = cache_dir / "ubuntu-base.img"
    overlay_img = cache_dir / "ubuntu-overlay.qcow2"
    uefi_vars = cache_dir / "uefi-vars.fd"

    # These tokens are replaced by Nix in the flake package.
    qemu_system = os.environ.get("QEMU_SYSTEM_AARCH64", "@qemu_system_aarch64@")
    qemu_img = os.environ.get("QEMU_IMG", "@qemu_img@")
    xorriso = os.environ.get("XORRISO", "@xorriso@")
    firmware_roots_raw = os.environ.get("FIRMWARE_SEARCH_DIRS", "@firmware_search_dirs@")

    # If the flake didn't substitute these tokens (or you're running the repo script
    # directly), fall back to PATH lookup.
    if qemu_system.startswith("@"):
        qemu_system = _which("qemu-system-aarch64") or ""
    if qemu_img.startswith("@"):
        qemu_img = _which("qemu-img") or ""
    if xorriso.startswith("@"):
        xorriso = _which("xorriso") or ""
    if firmware_roots_raw.startswith("@"):
        firmware_roots_raw = ""

    if not qemu_system:
        sys.stderr.write("Missing qemu-system-aarch64 in PATH (or QEMU_SYSTEM_AARCH64 not set).\n")
        return 1
    if not qemu_img:
        sys.stderr.write("Missing qemu-img in PATH (or QEMU_IMG not set).\n")
        return 1
    if not xorriso:
        sys.stderr.write("Missing xorriso in PATH (or XORRISO not set).\n")
        return 1

    firmware_search_dirs: list[Path] = []
    if firmware_roots_raw and "@firmware_search_dirs@" not in firmware_roots_raw:
        for part in firmware_roots_raw.split(":"):
            if part.strip():
                firmware_search_dirs.append(Path(part.strip()))

    qemu_share = Path(qemu_system).resolve().parent.parent / "share" / "qemu"
    firmware_search_dirs.append(qemu_share)
    firmware_search_dirs.append(Path("/opt/homebrew/share/qemu"))

    def port_free(port: int) -> bool:
        if port <= 0:
            return False
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            try:
                s.bind(("127.0.0.1", port))
            except OSError:
                return False
            return True

    ssh_port = args.ssh_port
    if ssh_port != 0 and not port_free(ssh_port):
        # Avoid failing hard if another VM instance is still running.
        for cand in range(ssh_port + 1, ssh_port + 50):
            if port_free(cand):
                ssh_port = cand
                break
        else:
            sys.stderr.write("No free port found for SSH forwarding; disabling SSH forwarding.\n")
            ssh_port = 0

    if args.ssh and ssh_port != 0:
        sys.stderr.write(
            "SSH (after first boot): ssh -o StrictHostKeyChecking=no "
            "-o UserKnownHostsFile=/dev/null -p "
            f"{ssh_port} theme@127.0.0.1\n"
        )

    if args.fresh:
        for pth in (overlay_img, seed_iso, uefi_vars):
            if pth.exists():
                pth.unlink()

    if args.base_image:
        src = Path(args.base_image).expanduser().resolve()
        if not src.is_file():
            sys.stderr.write(f"--base-image does not exist: {src}\n")
            return 2
        if not base_img.exists() or _sha256_file(base_img) != _sha256_file(src):
            shutil.copy2(src, base_img)
    elif not base_img.exists():
        sys.stderr.write(f"Downloading Ubuntu cloud image: {args.ubuntu_url}\n")
        _download(args.ubuntu_url, base_img)

    if share_dir.exists():
        shutil.rmtree(share_dir)
    (share_dir / "themes/grub").mkdir(parents=True, exist_ok=True)
    (share_dir / "themes/plymouth").mkdir(parents=True, exist_ok=True)
    (share_dir / "assets/fonts/undefined-medium").mkdir(parents=True, exist_ok=True)
    (share_dir / "THEME_SYNC_MARKER").write_text("hyper-theme-sync\n", encoding="utf-8")
    (share_dir / "HOLD_SECONDS").write_text(f"{args.hold_seconds}\n", encoding="utf-8")
    (share_dir / "GRUB_TIMEOUT").write_text(f"{args.grub_timeout}\n", encoding="utf-8")

    shutil.copytree(repo / "themes/grub/hyper-recovery", share_dir / "themes/grub/hyper-recovery")
    shutil.copytree(repo / "themes/plymouth/hyper-recovery", share_dir / "themes/plymouth/hyper-recovery")
    shutil.copy2(
        repo / "assets/fonts/undefined-medium/undefined-medium.ttf",
        share_dir / "assets/fonts/undefined-medium/undefined-medium.ttf",
    )

    _write_cloud_init(seed_dir)
    _make_cloud_init_seed_iso(xorriso, seed_dir, seed_iso)

    efi_code_env = os.environ.get("HYPER_THEME_EFI_CODE", "")
    efi_vars_env = os.environ.get("HYPER_THEME_EFI_VARS", "")
    efi_code: Path
    efi_vars_src: Path | None
    if efi_code_env:
        efi_code = Path(efi_code_env)
        if not efi_code.is_file():
            sys.stderr.write("HYPER_THEME_EFI_CODE was set but file does not exist.\n")
            return 1
        efi_vars_src = Path(efi_vars_env) if efi_vars_env else None
        if efi_vars_src and not efi_vars_src.is_file():
            sys.stderr.write("HYPER_THEME_EFI_VARS was set but file does not exist.\n")
            return 1
    else:
        fw = _find_firmware(firmware_search_dirs)
        if not fw:
            sys.stderr.write(
                "Failed to locate AArch64 UEFI firmware code (.fd). "
                "Provide HYPER_THEME_EFI_CODE (and optionally HYPER_THEME_EFI_VARS).\n"
            )
            return 1
        efi_code, efi_vars_src = fw

    # Some QEMU builds ship edk2 AArch64 code but not an AArch64 vars template.
    # In that case, prefer an ARM vars template if present; otherwise create a blank vars file.
    if efi_vars_src is None:
        for d in firmware_search_dirs:
            cand = d / "edk2-arm-vars.fd"
            if cand.is_file():
                efi_vars_src = cand
                break

    if not uefi_vars.exists():
        if efi_vars_src and efi_vars_src.is_file():
            shutil.copy2(efi_vars_src, uefi_vars)
        else:
            # 64 MiB vars (matches typical edk2 fd sizes in nixpkgs qemu share dir).
            uefi_vars.write_bytes(b"\0" * (64 * 1024 * 1024))
    # QEMU must be able to write UEFI variables.
    try:
        uefi_vars.chmod(0o600)
    except PermissionError:
        pass

    if not overlay_img.exists():
        _run([qemu_img, "create", "-f", "qcow2", "-F", "qcow2", "-b", str(base_img), str(overlay_img)])

    netdev = "user,id=net0"
    if ssh_port != 0:
        netdev = f"user,id=net0,hostfwd=tcp:127.0.0.1:{ssh_port}-:22"

    qemu_args = [
        qemu_system,
        "-machine",
        "virt,accel=hvf,highmem=off",
        "-cpu",
        "host",
        "-m",
        "2048",
        "-smp",
        "2",
        "-device",
        "qemu-xhci",
        "-device",
        "usb-kbd",
        "-device",
        "usb-mouse",
        "-device",
        "virtio-gpu-pci",
        "-netdev",
        netdev,
        "-device",
        "virtio-net-pci,netdev=net0",
        "-drive",
        f"if=pflash,format=raw,readonly=on,file={efi_code}",
        "-drive",
        f"if=pflash,format=raw,file={uefi_vars}",
        "-drive",
        f"if=virtio,format=qcow2,file={overlay_img}",
        "-drive",
        f"if=virtio,format=raw,media=cdrom,file={seed_iso}",
        "-drive",
        f"if=virtio,format=raw,file=fat:rw:{share_dir}",
    ]
    if args.headless:
        qemu_args.append("-nographic")

    os.execv(qemu_system, qemu_args)
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
