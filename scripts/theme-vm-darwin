#!/usr/bin/env bash
set -euo pipefail

ROOT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
cd "$ROOT_DIR"

usage() {
  cat <<'EOF'
Usage:
  scripts/theme-vm [--fresh] [--headless] [--ssh] [--]

On macOS arm64, this does NOT build NixOS images.
It boots a local Ubuntu ARM64 cloud VM in QEMU+HVF and syncs your GRUB/Plymouth
themes into it (then reboots once if changes were detected).

Options:
  --fresh        Recreate the VM overlay disk and cloud-init seed (keeps downloads).
  --headless     Run with -nographic (useful if you just want it to sync + reboot).
  --ssh          Print SSH command (port-forward to guest :22 on localhost:2222).
EOF
}

FRESH=0
HEADLESS=0
PRINT_SSH=0

while [[ $# -gt 0 ]]; do
  case "$1" in
    --fresh) FRESH=1; shift ;;
    --headless) HEADLESS=1; shift ;;
    --ssh) PRINT_SSH=1; shift ;;
    -h|--help) usage; exit 0 ;;
    --) shift; break ;;
    *) echo "Unknown arg: $1" >&2; usage; exit 2 ;;
  esac
done

# Codex's sandbox may restrict writing to `.codex/`. Use /tmp by default.
cache_dir="${HYPER_THEME_VM_DIR:-/tmp/hyper-theme-vm}"
mkdir -p "$cache_dir"

# Keep nix caches inside our writable cache dir (Codex sandbox often blocks ~/.cache).
export XDG_CACHE_HOME="$cache_dir/xdg-cache"
mkdir -p "$XDG_CACHE_HOME"

share_dir="$cache_dir/share"
seed_dir="$cache_dir/seed"
seed_iso="$cache_dir/seed.iso"
base_img="$cache_dir/ubuntu-base.img"
overlay_img="$cache_dir/ubuntu-overlay.qcow2"

qemu_bin=""
if command -v qemu-system-aarch64 >/dev/null 2>&1; then
  qemu_bin="qemu-system-aarch64"
fi

run_qemu() {
  if [[ -n "$qemu_bin" ]]; then
    exec "$qemu_bin" "$@"
  fi
  exec nix shell nixpkgs#qemu --command qemu-system-aarch64 "$@"
}

ensure_ubuntu_base() {
  if [[ -f "$base_img" ]]; then
    return 0
  fi

  # Migration: if an older run downloaded into the repo, reuse it.
  if [[ -f "$ROOT_DIR/.codex/theme-vm/ubuntu-base.img" ]]; then
    cp "$ROOT_DIR/.codex/theme-vm/ubuntu-base.img" "$base_img"
    return 0
  fi

  # Ubuntu cloud image (ARM64). Download once; overlay persists across runs.
  # URL can be overridden via UBUNTU_CLOUDIMG_URL.
  url="${UBUNTU_CLOUDIMG_URL:-https://cloud-images.ubuntu.com/noble/current/noble-server-cloudimg-arm64.img}"
  echo "Downloading Ubuntu cloud image: $url" >&2
  curl -fsSL -L "$url" -o "$base_img.tmp"
  mv "$base_img.tmp" "$base_img"
}

rebuild_share_dir() {
  rm -rf "$share_dir"
  mkdir -p "$share_dir"

  # Marker so the guest can reliably find the "theme drive".
  echo "hyper-theme-sync" > "$share_dir/THEME_SYNC_MARKER"

  mkdir -p "$share_dir/themes/grub"
  mkdir -p "$share_dir/themes/plymouth"
  mkdir -p "$share_dir/assets/fonts/undefined-medium"

  cp -R "$ROOT_DIR/themes/grub/hyper-recovery" "$share_dir/themes/grub/"
  cp -R "$ROOT_DIR/themes/plymouth/hyper-recovery" "$share_dir/themes/plymouth/"
  cp "$ROOT_DIR/assets/fonts/undefined-medium/undefined-medium.ttf" \
    "$share_dir/assets/fonts/undefined-medium/undefined-medium.ttf"
}

make_seed_iso() {
  rm -rf "$seed_dir"
  mkdir -p "$seed_dir"

  cat >"$seed_dir/meta-data" <<'EOF'
instance-id: hyper-theme-vm
local-hostname: hyper-theme-vm
EOF

  # Cloud-init will install packages, install a theme-sync service, then reboot once
  # after the first successful sync so Plymouth changes show on the next boot.
  cat >"$seed_dir/user-data" <<'EOF'
#cloud-config
ssh_pwauth: true
disable_root: false
users:
  - name: theme
    groups: [sudo]
    sudo: ALL=(ALL) NOPASSWD:ALL
    shell: /bin/bash
    lock_passwd: false
chpasswd:
  expire: false
  list: |
    theme:theme

write_files:
  - path: /usr/local/sbin/hyper-theme-sync
    permissions: '0755'
    content: |
      #!/usr/bin/env bash
      set -euo pipefail

      state_dir=/var/lib/hyper-theme-sync
      mkdir -p "$state_dir"
      stamp="$state_dir/last.sha256"

      find_theme_dev() {
        # Look for the vfat "theme drive" by marker file.
        while IFS= read -r dev; do
          mnt="$(mktemp -d)"
          if mount -t vfat -o ro "$dev" "$mnt" 2>/dev/null; then
            if [[ -f "$mnt/THEME_SYNC_MARKER" ]]; then
              echo "$dev"
              umount "$mnt" || true
              rmdir "$mnt" || true
              return 0
            fi
            umount "$mnt" || true
          fi
          rmdir "$mnt" || true
        done < <(lsblk -pnro NAME,FSTYPE,TYPE | awk '$2=="vfat" && $3=="part"{print $1} $2=="vfat" && $3=="disk"{print $1}')
        return 1
      }

      dev="$(find_theme_dev || true)"
      if [[ -z "${dev:-}" ]]; then
        echo "hyper-theme-sync: no theme drive found; skipping" >&2
        exit 0
      fi

      mnt=/mnt/hyper-theme
      mkdir -p "$mnt"
      mount -t vfat -o ro "$dev" "$mnt"
      trap 'umount "$mnt" 2>/dev/null || true' EXIT

      # Hash the inputs we care about (fast-ish, but still deterministic).
      new_sha="$(
        (cd "$mnt" && \
          find themes/grub/hyper-recovery themes/plymouth/hyper-recovery assets/fonts/undefined-medium -type f -print0 \
          | LC_ALL=C sort -z \
          | xargs -0 sha256sum \
          | sha256sum \
          | awk '{print $1}')
      )"

      old_sha="$(cat "$stamp" 2>/dev/null || true)"
      if [[ -n "$old_sha" && "$old_sha" == "$new_sha" ]]; then
        echo "hyper-theme-sync: no changes" >&2
        exit 0
      fi

      echo "hyper-theme-sync: applying theme update..." >&2

      # Ensure packages exist (first boot).
      export DEBIAN_FRONTEND=noninteractive
      apt-get update -y
      apt-get install -y grub-efi-arm64 grub-common plymouth plymouth-themes

      # Install GRUB theme.
      grub_theme_dir=/boot/grub/themes/snosu-hyper-recovery
      rm -rf "$grub_theme_dir"
      mkdir -p "$grub_theme_dir"
      cp -R "$mnt/themes/grub/hyper-recovery/"* "$grub_theme_dir/"

      # Generate GRUB fonts from the TTF and normalize theme font family name.
      font_src="$mnt/assets/fonts/undefined-medium/undefined-medium.ttf"
      grub-mkfont -s 12 -o "$grub_theme_dir/undefined_medium_12.pf2" "$font_src"
      grub-mkfont -s 14 -o "$grub_theme_dir/undefined_medium_14.pf2" "$font_src"
      grub-mkfont -s 16 -o "$grub_theme_dir/undefined_medium_16.pf2" "$font_src"
      grub-mkfont -s 24 -o "$grub_theme_dir/undefined_medium_24.pf2" "$font_src"
      grub-mkfont -s 28 -o "$grub_theme_dir/undefined_medium_28.pf2" "$font_src"

      sed -i 's/Hyper Street Fighter 2 Regular/Undefined Medium/g' "$grub_theme_dir/theme.txt" || true
      sed -i 's/Hyper Fighting Regular/Undefined Medium/g' "$grub_theme_dir/theme.txt" || true

      # Force GRUB menu to be visible for theme iteration.
      grub_defaults=/etc/default/grub
      if ! grep -q '^GRUB_TIMEOUT_STYLE=' "$grub_defaults" 2>/dev/null; then
        echo 'GRUB_TIMEOUT_STYLE=menu' >> "$grub_defaults"
      else
        sed -i 's/^GRUB_TIMEOUT_STYLE=.*/GRUB_TIMEOUT_STYLE=menu/' "$grub_defaults"
      fi
      if ! grep -q '^GRUB_TIMEOUT=' "$grub_defaults" 2>/dev/null; then
        echo 'GRUB_TIMEOUT=10' >> "$grub_defaults"
      else
        sed -i 's/^GRUB_TIMEOUT=.*/GRUB_TIMEOUT=10/' "$grub_defaults"
      fi

      if grep -q '^GRUB_THEME=' "$grub_defaults" 2>/dev/null; then
        sed -i "s|^GRUB_THEME=.*|GRUB_THEME=${grub_theme_dir}/theme.txt|" "$grub_defaults"
      else
        echo "GRUB_THEME=${grub_theme_dir}/theme.txt" >> "$grub_defaults"
      fi
      update-grub

      # Install Plymouth theme.
      ply_theme_dir=/usr/share/plymouth/themes/snosu-hyper-recovery
      rm -rf "$ply_theme_dir"
      mkdir -p "$ply_theme_dir"
      cp -R "$mnt/themes/plymouth/hyper-recovery/"* "$ply_theme_dir/"
      cp "$font_src" "$ply_theme_dir/undefined-medium.ttf" || true

      # Fix ImageDir to the installed path (repo uses a relative dev path).
      if [[ -f "$ply_theme_dir/snosu-hyper-recovery.plymouth" ]]; then
        sed -i "s|^ImageDir=.*|ImageDir=${ply_theme_dir}|" "$ply_theme_dir/snosu-hyper-recovery.plymouth" || true
      fi

      plymouth-set-default-theme -R snosu-hyper-recovery || true

      echo "$new_sha" > "$stamp"
      sync || true

      # Reboot once so initramfs Plymouth changes show.
      echo "hyper-theme-sync: done; rebooting to show Plymouth theme..." >&2
      systemctl reboot

  - path: /etc/systemd/system/hyper-theme-sync.service
    permissions: '0644'
    content: |
      [Unit]
      Description=Hyper theme sync (GRUB + Plymouth)
      After=network-online.target
      Wants=network-online.target

      [Service]
      Type=oneshot
      ExecStart=/usr/local/sbin/hyper-theme-sync

      [Install]
      WantedBy=multi-user.target

runcmd:
  - [ systemctl, daemon-reload ]
  - [ systemctl, enable, --now, hyper-theme-sync.service ]
EOF

  rm -f "$seed_iso"
  # Create a cloud-init "cidata" ISO using built-in macOS tooling.
  hdiutil makehybrid -quiet -o "$seed_iso" -hfs -joliet -iso -default-volume-name cidata "$seed_dir"
}

ensure_firmware() {
  local code="${HYPER_THEME_EFI_CODE:-}"
  local vars="${HYPER_THEME_EFI_VARS:-}"

  first_match() {
    local d="$1"
    local regex="$2"
    find "$d" -maxdepth 1 -type f -print 2>/dev/null | LC_ALL=C sort | grep -Ei "$regex" | head -n 1 || true
  }

  find_from_dir() {
    local d="$1"
    [[ -d "$d" ]] || return 1

    if [[ -z "$code" ]]; then
      code="$(first_match "$d" '((edk2|aavmf|qemu).*aarch64.*code.*\.fd$)|(QEMU_EFI.*\.fd$)')"
    fi
    if [[ -z "$vars" ]]; then
      vars="$(first_match "$d" '((edk2|aavmf|qemu).*aarch64.*vars.*\.fd$)')"
    fi
    [[ -n "$code" && -n "$vars" ]]
  }

  # Common host locations.
  find_from_dir "/opt/homebrew/share/qemu" || true
  find_from_dir "/usr/local/share/qemu" || true
  find_from_dir "/Applications/UTM.app/Contents/Resources/qemu" || true
  find_from_dir "/Applications/UTM.app/Contents/Resources" || true
  find_from_dir "$HOME/.nix-profile/share/qemu" || true

  # Relative to an installed qemu binary (if present).
  if [[ -n "$qemu_bin" ]]; then
    qemu_share="$(cd "$(dirname "$qemu_bin")/../share/qemu" 2>/dev/null && pwd || true)"
    if [[ -n "$qemu_share" ]]; then
      find_from_dir "$qemu_share" || true
    fi
  fi

  # If qemu is not installed, try to locate firmware via a nix shell providing qemu.
  if [[ -z "$code" || -z "$vars" ]]; then
    set +e
    readarray -t fw_lines < <(
      nix shell nixpkgs#qemu --command bash -lc '
        set -euo pipefail
        q="$(command -v qemu-system-aarch64)"
        share="$(cd "$(dirname "$q")/../share/qemu" && pwd)"
        code="$(find "$share" -maxdepth 1 -type f -print | sort | grep -Ei "((edk2|aavmf|qemu).*aarch64.*code.*\\.fd$)|(QEMU_EFI.*\\.fd$)" | head -n 1 || true)"
        vars="$(find "$share" -maxdepth 1 -type f -print | sort | grep -Ei "((edk2|aavmf|qemu).*aarch64.*vars.*\\.fd$)" | head -n 1 || true)"
        printf "%s\n%s\n" "$code" "$vars"
      ' 2>/dev/null
    )
    set -e
    if [[ -z "$code" && -n "${fw_lines[0]:-}" ]]; then code="${fw_lines[0]}"; fi
    if [[ -z "$vars" && -n "${fw_lines[1]:-}" ]]; then vars="${fw_lines[1]}"; fi
  fi

  if [[ -z "${code:-}" || ! -f "$code" || -z "${vars:-}" || ! -f "$vars" ]]; then
    cat >&2 <<EOF
Failed to locate AArch64 UEFI firmware (.fd files).

Fix options:
1) Install QEMU via Homebrew: brew install qemu  (firmware usually under /opt/homebrew/share/qemu)
2) Install UTM and point to its firmware
3) Export explicit paths:
   HYPER_THEME_EFI_CODE=/path/to/edk2-aarch64-code.fd
   HYPER_THEME_EFI_VARS=/path/to/edk2-aarch64-vars.fd
EOF
    exit 1
  fi

  vars_dst="$cache_dir/uefi-vars.fd"
  if [[ "$FRESH" -eq 1 || ! -f "$vars_dst" ]]; then
    cp "$vars" "$vars_dst"
  fi

  echo "$code" > "$cache_dir/uefi-code.path"
  echo "$vars_dst" > "$cache_dir/uefi-vars.path"
}

ensure_overlay() {
  if [[ "$FRESH" -eq 1 ]]; then
    rm -f "$overlay_img" "$seed_iso"
  fi

  if [[ -f "$overlay_img" ]]; then
    return 0
  fi

  if command -v qemu-img >/dev/null 2>&1; then
    qemu-img create -f qcow2 -F qcow2 -b "$base_img" "$overlay_img" >/dev/null
    return 0
  fi

  nix shell nixpkgs#qemu --command qemu-img create -f qcow2 -F qcow2 -b "$base_img" "$overlay_img" >/dev/null
}

ensure_ubuntu_base
rebuild_share_dir
make_seed_iso
ensure_firmware
ensure_overlay

uefi_code="$(cat "$cache_dir/uefi-code.path")"
uefi_vars="$(cat "$cache_dir/uefi-vars.path")"

if [[ "$PRINT_SSH" -eq 1 ]]; then
  echo "SSH (after first boot): ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -p 2222 theme@127.0.0.1" >&2
fi

qemu_args=(
  -machine virt,accel=hvf,highmem=off
  -cpu host
  -m 2048
  -smp 2
  -device virtio-gpu-pci
  -device usb-kbd -device usb-mouse
  -netdev user,id=net0,hostfwd=tcp:127.0.0.1:2222-:22
  -device virtio-net-pci,netdev=net0
  -drive if=pflash,format=raw,readonly=on,file="$uefi_code"
  -drive if=pflash,format=raw,file="$uefi_vars"
  -drive if=virtio,format=qcow2,file="$overlay_img"
  -drive if=virtio,format=raw,media=cdrom,file="$seed_iso"
  -drive if=virtio,format=raw,file="fat:rw:$share_dir"
)

if [[ "$HEADLESS" -eq 1 ]]; then
  qemu_args+=(-nographic)
fi

run_qemu "${qemu_args[@]}"
